[
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save (Submitted Document)",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.708020",
  "module": "Electro Zone",
  "name": "Item - Auto Assign Supplier from Brand",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Item",
  "script": "if doc.brand and not doc.get(\"default_supplier\"):\r\n    supplier = frappe.db.get_value(\"Brand\", doc.brand, \"default_supplier\")\r\n    if supplier:\r\n        doc.default_supplier = supplier\r\n        frappe.msgprint(f\"Supplier auto-assigned: {supplier}\")",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.710219",
  "module": "Electro Zone",
  "name": "Item - Validate Uniqueness",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Item",
  "script": "# Validate uniqueness of (Brand, Item Group, Item Model)\r\n# Note: frappe is already available in Server Scripts context\r\n\r\nif doc.brand and doc.item_group and doc.get(\"item_model\"):\r\n    filters = {\r\n        \"brand\": doc.brand,\r\n        \"item_group\": doc.item_group,\r\n        \"item_model\": doc.item_model\r\n    }\r\n\r\n    # Exclude current document if updating\r\n    if not doc.is_new():\r\n        filters[\"name\"] = [\"!=\", doc.name]\r\n\r\n    existing = frappe.db.exists(\"Item\", filters)\r\n\r\n    if existing:\r\n        frappe.throw(\r\n            f\"Item with Brand '{doc.brand}', Item Group '{doc.item_group}', and Model '{doc.item_model}' already exists: {existing}\"\r\n        )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.760445",
  "module": "Electro Zone",
  "name": "Sales Order - Move to Hold on Submit",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# Move stock to Hold warehouse when a Sales Order is submitted (v15.8)\r\n# Notes:\r\n# - In Server Scripts, frappe and frappe.utils are available (no import needed)\r\n# - Use event: After Submit\r\n# - The 'doc' variable is automatically available in Server Script context\r\n\r\n# ============================================================\r\n# STEP 1: CAPTURE SOURCE WAREHOUSE (BEFORE ANY MODIFICATIONS)\r\n# ============================================================\r\n# Store the original source warehouse for stock return on cancellation\r\n# CRITICAL: Do this FIRST before any other operations\r\nsource_warehouse = None\r\nfor so_item in doc.items:\r\n    if so_item.warehouse:\r\n        source_warehouse = so_item.warehouse\r\n        break\r\n\r\nif source_warehouse:\r\n    # Set custom_source_warehouse field (requires \"Allow on Submit\" to be enabled)\r\n    frappe.db.set_value(\r\n        \"Sales Order\",\r\n        doc.name,\r\n        \"custom_source_warehouse\",\r\n        source_warehouse,\r\n        update_modified=False\r\n    )\r\n\r\n# ============================================================\r\n# STEP 2: SKIP CONDITIONS CHECK\r\n# ============================================================\r\n# Skip auto-created submissions or those pending review\r\n# Check for auto-creation via comment instead of _from_auto_creation flag\r\ncomments = frappe.get_all(\r\n    \"Comment\",\r\n    filters={\r\n        \"reference_doctype\": \"Sales Order\",\r\n        \"reference_name\": doc.name,\r\n        \"content\": \"AUTO_CREATED_FROM_MARKETPLACE_ORDER\"\r\n    },\r\n    limit=1\r\n)\r\n\r\nis_auto_created = len(comments) > 0\r\nskip_conditions = is_auto_created or doc.status == \"Pending Review\"\r\n\r\nif skip_conditions:\r\n    frappe.msgprint(\r\n        \"Auto-created or Pending Review Sales Order. Skipping Hold movement on this submission.\",\r\n        indicator=\"orange\",\r\n        title=\"Skipped\"\r\n    )\r\nelse:\r\n    # ============================================================\r\n    # STEP 3: MOVE STOCK TO HOLD WAREHOUSE\r\n    # ============================================================\r\n    # Find Hold warehouse (non-group) for the company\r\n    hold_warehouse = frappe.db.get_value(\r\n        \"Warehouse\",\r\n        {\r\n            \"warehouse_name\": [\"like\", \"%Hold%\"],\r\n            \"company\": doc.company,\r\n            \"is_group\": 0\r\n        },\r\n        \"name\"\r\n    )\r\n\r\n    if not hold_warehouse:\r\n        frappe.throw(f\"Hold warehouse not found for company {doc.company}. Please create it first.\")\r\n\r\n    # Create Stock Entry (Material Transfer)\r\n    stock_entry = frappe.new_doc(\"Stock Entry\")\r\n    stock_entry.stock_entry_type = \"Material Transfer\"\r\n    stock_entry.company = doc.company\r\n    stock_entry.posting_date = doc.transaction_date\r\n    stock_entry.posting_time = frappe.utils.nowtime()\r\n    stock_entry.set_posting_time = 1\r\n\r\n    items_added = False\r\n\r\n    for so_item in doc.items:\r\n        # Validate source and quantities\r\n        if not so_item.warehouse or frappe.utils.flt(so_item.qty) <= 0:\r\n            continue\r\n\r\n        if so_item.warehouse == hold_warehouse:\r\n            continue\r\n\r\n        available_qty = frappe.utils.flt(\r\n            frappe.db.get_value(\r\n                \"Bin\",\r\n                {\"item_code\": so_item.item_code, \"warehouse\": so_item.warehouse},\r\n                \"actual_qty\"\r\n            ) or 0\r\n        )\r\n        if available_qty < frappe.utils.flt(so_item.qty):\r\n            frappe.throw(\r\n                f\"Insufficient stock for <b>{so_item.item_code}</b> in <b>{so_item.warehouse}</b>. \"\r\n                f\"Available: <b>{available_qty}</b>, Required: <b>{so_item.qty}</b>\"\r\n            )\r\n\r\n        stock_uom = frappe.db.get_value(\"Item\", so_item.item_code, \"stock_uom\")\r\n\r\n        stock_entry.append(\"items\", {\r\n            \"item_code\": so_item.item_code,\r\n            \"qty\": frappe.utils.flt(so_item.qty),\r\n            \"s_warehouse\": so_item.warehouse,\r\n            \"t_warehouse\": hold_warehouse,\r\n            \"uom\": so_item.uom or stock_uom,\r\n            \"stock_uom\": stock_uom,\r\n            \"conversion_factor\": frappe.utils.flt(so_item.conversion_factor) or 1.0,\r\n            \"transfer_qty\": frappe.utils.flt(so_item.qty) * (frappe.utils.flt(so_item.conversion_factor) or 1.0),\r\n            \"sales_order\": doc.name  # Link each item to SO (for reverse lookup)\r\n        })\r\n        items_added = True\r\n\r\n    if items_added:\r\n        stock_entry.insert(ignore_permissions=True)\r\n        stock_entry.submit()\r\n\r\n        # Update Sales Order items to use Hold warehouse\r\n        # This ensures Delivery Notes pull from Hold warehouse\r\n        for so_item in doc.items:\r\n            if so_item.warehouse and so_item.warehouse != hold_warehouse:\r\n                frappe.db.set_value(\r\n                    \"Sales Order Item\",\r\n                    so_item.name,\r\n                    \"warehouse\",\r\n                    hold_warehouse,\r\n                    update_modified=False\r\n                )\r\n\r\n        doc.add_comment(\r\n            \"Comment\",\r\n            f\"Stock moved to Hold via Stock Entry <a href=\\\"/app/stock-entry/{stock_entry.name}\\\">{stock_entry.name}</a>\"\r\n        )\r\n\r\n        frappe.msgprint(\r\n            f\"Stock Entry <b>{stock_entry.name}</b> created. Stock moved to <b>{hold_warehouse}</b>\",\r\n            indicator=\"green\",\r\n            title=\"Stock Reserved\",\r\n            alert=True\r\n        )\r\n\r\n        # Auto-create Delivery Note in Pending Dispatch state\r\n        dn = frappe.new_doc(\"Delivery Note\")\r\n        dn.customer = doc.customer\r\n        dn.posting_date = frappe.utils.nowdate()\r\n        dn.posting_time = frappe.utils.nowtime()\r\n        dn.company = doc.company\r\n        dn.set_posting_time = 1\r\n\r\n        # Add items from Sales Order\r\n        for so_item in doc.items:\r\n            dn.append(\"items\", {\r\n                \"item_code\": so_item.item_code,\r\n                \"item_name\": so_item.item_name,\r\n                \"description\": so_item.description,\r\n                \"qty\": so_item.qty,\r\n                \"rate\": so_item.rate,\r\n                \"warehouse\": hold_warehouse,\r\n                \"uom\": so_item.uom,\r\n                \"stock_uom\": so_item.stock_uom,\r\n                \"conversion_factor\": so_item.conversion_factor or 1,\r\n                \"against_sales_order\": doc.name,\r\n                \"so_detail\": so_item.name\r\n            })\r\n\r\n        # Insert DN to generate docname\r\n        dn.insert(ignore_permissions=True)\r\n\r\n        # Set workflow state to Pending Dispatch\r\n        frappe.db.set_value(\r\n            \"Delivery Note\",\r\n            dn.name,\r\n            \"workflow_state\",\r\n            \"Pending Dispatch\",\r\n            update_modified=False\r\n        )\r\n\r\n        # Add audit comment on DN\r\n        dn.add_comment(\r\n            \"Comment\",\r\n            f\"Auto-created from Sales Order {doc.name} on submit. Awaiting Stock Manager review.\"\r\n        )\r\n\r\n        # Add comment on SO linking to DN\r\n        doc.add_comment(\r\n            \"Comment\",\r\n            f\"Delivery Note <a href=\\\"/app/delivery-note/{dn.name}\\\">{dn.name}</a> created in Pending Dispatch state\"\r\n        )\r\n\r\n        frappe.msgprint(\r\n            f\"Delivery Note <b>{dn.name}</b> created in Pending Dispatch state\",\r\n            indicator=\"blue\",\r\n            title=\"DN Created\",\r\n            alert=True\r\n        )\r\n    else:\r\n        frappe.msgprint(\r\n            \"No items to transfer to Hold warehouse.\",\r\n            indicator=\"orange\",\r\n            title=\"No Transfer\"\r\n        )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.724542",
  "module": "Electro Zone",
  "name": "Purchase Receipt - Auto Populate Rate",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Purchase Receipt",
  "script": "# Auto-populate rate and valuation rate from Purchase Order\r\n# Ensures storekeeper doesn't need to see/enter prices\r\n\r\nfor item in doc.items:\r\n    # If rate is not set and we have a PO reference\r\n    if not item.rate and item.purchase_order:\r\n        # Fetch rate from Purchase Order Item\r\n        po_rate = frappe.db.get_value(\r\n            \"Purchase Order Item\",\r\n            {\r\n                \"parent\": item.purchase_order,\r\n                \"item_code\": item.item_code\r\n            },\r\n            \"rate\"\r\n        )\r\n\r\n        if po_rate:\r\n            item.rate = po_rate\r\n            item.valuation_rate = po_rate\r\n\r\n    # If still no rate, try to get from Item master\r\n    if not item.rate:\r\n        # First, check if Item has Repeat pricing data\r\n        item_repeat_data = frappe.db.get_value(\r\n            \"Item\",\r\n            item.item_code,\r\n            [\r\n                \"valuation_rate\",\r\n                \"custom_repeat_final_rate_price\",\r\n                \"custom_repeat_quarter_discount\",\r\n                \"custom_repeat_yearly_dis\"\r\n            ],\r\n            as_dict=1\r\n        )\r\n\r\n        # Extract Repeat data\r\n        final_rate_price = item_repeat_data.get(\"custom_repeat_final_rate_price\") or 0\r\n        quarter_discount = item_repeat_data.get(\"custom_repeat_quarter_discount\") or 0\r\n        yearly_discount = item_repeat_data.get(\"custom_repeat_yearly_dis\") or 0\r\n        existing_valuation_rate = item_repeat_data.get(\"valuation_rate\") or 0\r\n\r\n        # If Item has Repeat data, recalculate valuation_rate to ensure it's current\r\n        if final_rate_price > 0:\r\n            # Sum both discount percentages\r\n            total_discount_pct = quarter_discount + yearly_discount\r\n\r\n            # Calculate valuation rate with summed discount\r\n            calculated_valuation_rate = final_rate_price - (final_rate_price * total_discount_pct / 100)\r\n\r\n            # Use calculated rate for PR\r\n            item.rate = calculated_valuation_rate\r\n            item.valuation_rate = calculated_valuation_rate\r\n\r\n            # If different from Item master, update Item master too (defensive)\r\n            if existing_valuation_rate != calculated_valuation_rate:\r\n                frappe.db.set_value(\"Item\", item.item_code, \"valuation_rate\", calculated_valuation_rate, update_modified=False)\r\n        else:\r\n            # No Repeat data - use existing valuation_rate or default to 0\r\n            if existing_valuation_rate:\r\n                item.rate = existing_valuation_rate\r\n                item.valuation_rate = existing_valuation_rate\r\n            else:\r\n                # Set a default to avoid validation error\r\n                item.rate = 0\r\n                item.valuation_rate = 0\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.732709",
  "module": "Electro Zone",
  "name": "Purchase Receipt - Validate Received Quantity",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Purchase Receipt",
  "script": "# Validate received quantity and update qty field\r\n# Ensures Stock User cannot receive more than ordered\r\n# Updates totals to reflect only received quantity\r\n\r\nfor item in doc.items:\r\n    # Store the original ordered quantity (from PO)\r\n    if not item.get('ordered_quantity_original'):\r\n        item.ordered_quantity_original = item.qty\r\n\r\n    ordered_qty = item.ordered_quantity_original\r\n\r\n    # Get the received quantity from custom field\r\n    received_qty = item.get('custom_received_quantity') or 0\r\n\r\n    # Validation: Received quantity cannot exceed ordered quantity\r\n    if received_qty > ordered_qty:\r\n        frappe.throw(\r\n            f\"Row #{item.idx}: Received Quantity ({received_qty}) cannot be greater than Ordered Quantity ({ordered_qty}) for item {item.item_code}\"\r\n        )\r\n\r\n    # Validation: Received quantity must be greater than 0\r\n    if received_qty <= 0:\r\n        frappe.throw(\r\n            f\"Row #{item.idx}: Received Quantity must be greater than 0 for item {item.item_code}\"\r\n        )\r\n\r\n    # Received Qty must equal Accepted + Rejected Qty\r\n    item.received_qty = received_qty\r\n    item.accepted_qty = received_qty\r\n    item.rejected_qty = 0\r\n\r\n    # Update the qty field with received quantity\r\n    # This updates the stock entry and totals\r\n    item.qty = received_qty\r\n\r\n    # Recalculate amounts based on received quantity\r\n    if item.rate:\r\n        item.amount = received_qty * item.rate\r\n        item.base_amount = received_qty * item.base_rate if item.base_rate else item.amount\r\n\r\n    # If received less than ordered, PO will remain open\r\n    if received_qty < ordered_qty:\r\n        frappe.msgprint(\r\n            f\"Item {item.item_code}: Received {received_qty} out of {ordered_qty}. Purchase Order will remain open for the remaining quantity.\",\r\n            indicator='orange'\r\n        )\r\n\r\n# Recalculate document totals\r\ndoc.calculate_taxes_and_totals()",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.723021",
  "module": "Electro Zone",
  "name": "Purchase Order - Validate Supplier Items",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Purchase Order",
  "script": "for item in doc.items:\r\n    if item.item_code:\r\n        # Get the item's custom_primary_supplier\r\n        item_doc = frappe.get_doc('Item', item.item_code)\r\n        \r\n        # Use the get() method or check if field exists\r\n        custom_primary_supplier = item_doc.get('custom_primary_supplier')\r\n        \r\n        if custom_primary_supplier:\r\n            # Check if the item's custom_primary_supplier matches the PO supplier\r\n            if custom_primary_supplier != doc.supplier:\r\n                frappe.throw(\r\n                    f\"Item {item.item_code} is not linked to supplier {doc.supplier}. \"\r\n                    f\"This item is linked to {custom_primary_supplier}. \"\r\n                    f\"Please select items that are linked to the selected supplier.\"\r\n                )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "sync_standard_buying_from_item",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.679559",
  "module": "Electro Zone",
  "name": "Sync Standard Buying from Item API",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# Sync Standard Buying from Item API (ERPNext v15.8+)\r\n# Script Type: API\r\n# API Method: sync_standard_buying_from_item\r\n#\r\n# Purpose:\r\n# - Manually sync Standard Buying Item Price from Item's custom_repeat_final_rate_price\r\n# - Useful when Item Repeat tab is manually edited\r\n# - Can be triggered from Item form via client script button\r\n# - Supports single item or batch processing\r\n#\r\n# Parameters:\r\n# - item_code (string): Single item code to sync\r\n# - item_codes (list): Multiple item codes for batch processing\r\n#\r\n# Returns:\r\n# - success: boolean\r\n# - message: string\r\n# - updated_count: number of items updated\r\n#\r\n# Note: In Server Scripts, `frappe` is already available—no import needed.\r\n\r\n# Get parameters from request\r\nitem_code = frappe.form_dict.get(\"item_code\")\r\nitem_codes = frappe.form_dict.get(\"item_codes\") or []\r\n\r\n# Convert single item to list\r\nif item_code and not item_codes:\r\n    item_codes = [item_code]\r\n\r\nif not item_codes:\r\n    frappe.response[\"message\"] = {\r\n        \"success\": False,\r\n        \"message\": \"No item codes provided\",\r\n        \"updated_count\": 0\r\n    }\r\nelse:\r\n    updated_count = 0\r\n    errors = []\r\n\r\n    for code in item_codes:\r\n        try:\r\n            # Get Item's repeat final rate price\r\n            item_data = frappe.db.get_value(\"Item\", code,\r\n                [\"custom_repeat_final_rate_price\", \"custom_repeat_last_updated\"],\r\n                as_dict=True\r\n            )\r\n\r\n            if not item_data:\r\n                errors.append(f\"{code}: Item not found\")\r\n                continue\r\n\r\n            final_rate_price = item_data.get(\"custom_repeat_final_rate_price\")\r\n\r\n            if final_rate_price is None or final_rate_price == 0:\r\n                errors.append(f\"{code}: No repeat final rate price set\")\r\n                continue\r\n\r\n            # Check if Item Price exists for Standard Buying\r\n            existing_price = frappe.db.exists(\"Item Price\", {\r\n                \"item_code\": code,\r\n                \"price_list\": \"Standard Buying\"\r\n            })\r\n\r\n            if existing_price:\r\n                # Update existing Item Price\r\n                frappe.db.set_value(\"Item Price\", existing_price, {\r\n                    \"price_list_rate\": final_rate_price,\r\n                    \"valid_from\": item_data.get(\"custom_repeat_last_updated\") or frappe.utils.now()\r\n                })\r\n            else:\r\n                # Create new Item Price record\r\n                item_price = frappe.new_doc(\"Item Price\")\r\n                item_price.item_code = code\r\n                item_price.price_list = \"Standard Buying\"\r\n                item_price.price_list_rate = final_rate_price\r\n\r\n                # Get currency from Global Defaults\r\n                currency = frappe.db.get_single_value(\"Global Defaults\", \"default_currency\") or \"EGP\"\r\n                item_price.currency = currency\r\n\r\n                item_price.valid_from = item_data.get(\"custom_repeat_last_updated\") or frappe.utils.now()\r\n                item_price.flags.ignore_permissions = True\r\n                item_price.insert()\r\n\r\n            updated_count = updated_count + 1\r\n\r\n        except Exception as e:\r\n            errors.append(f\"{code}: {str(e)}\")\r\n\r\n    # Return result\r\n    if updated_count > 0:\r\n        frappe.response[\"message\"] = {\r\n            \"success\": True,\r\n            \"message\": f\"Successfully updated {updated_count} item(s). \" + (f\"Errors: {', '.join(errors[:3])}\" if errors else \"\"),\r\n            \"updated_count\": updated_count,\r\n            \"errors\": errors\r\n        }\r\n    else:\r\n        frappe.response[\"message\"] = {\r\n            \"success\": False,\r\n            \"message\": f\"No items updated. Errors: {', '.join(errors[:5])}\",\r\n            \"updated_count\": 0,\r\n            \"errors\": errors\r\n        }",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.718947",
  "module": "Electro Zone",
  "name": "Purchase Order - Auto-Sync Standard Buying on Item Add",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Purchase Order",
  "script": "# Purchase Order - Auto-Sync Standard Buying on Item Add (ERPNext v15.8+)\r\n# Event: Before Save\r\n#\r\n# Purpose:\r\n# - Automatically create/update Standard Buying Item Price for items added to PO\r\n# - Ensures old items (historical data) have Standard Buying prices before PO creation\r\n# - Prevents stale data in Purchase Orders\r\n# - Handles items that have custom_repeat_final_rate_price but no Item Price record\r\n#\r\n# Workflow:\r\n# 1. Loop through all items in Purchase Order\r\n# 2. Check if Standard Buying Item Price exists\r\n# 3. If missing but custom_repeat_final_rate_price > 0: Auto-create Item Price\r\n# 4. Log action in PO comments for audit trail\r\n#\r\n# Trigger: Every time PO is saved (Draft or Submitted)\r\n# Note: In Server Scripts, `frappe` is already available—no import needed.\r\n\r\n# Track items that were auto-synced for logging\r\nauto_synced_items = []\r\n\r\n# Loop through all items in the Purchase Order\r\nfor item in doc.items:\r\n    item_code = item.item_code\r\n\r\n    if not item_code:\r\n        continue\r\n\r\n    # Check if Standard Buying Item Price exists\r\n    existing_price = frappe.db.exists(\"Item Price\", {\r\n        \"item_code\": item_code,\r\n        \"price_list\": \"Standard Buying\"\r\n    })\r\n\r\n    if not existing_price:\r\n        # Item Price doesn't exist - check if we can create it\r\n        try:\r\n            # Get Item's repeat final rate price\r\n            item_data = frappe.db.get_value(\"Item\", item_code,\r\n                [\"custom_repeat_final_rate_price\", \"custom_repeat_last_updated\"],\r\n                as_dict=True\r\n            )\r\n\r\n            if not item_data:\r\n                continue\r\n\r\n            final_rate_price = item_data.get(\"custom_repeat_final_rate_price\")\r\n\r\n            # Only create if item has a valid repeat price\r\n            if final_rate_price and final_rate_price > 0:\r\n                # Create new Item Price record for Standard Buying\r\n                item_price = frappe.new_doc(\"Item Price\")\r\n                item_price.item_code = item_code\r\n                item_price.price_list = \"Standard Buying\"\r\n                item_price.price_list_rate = final_rate_price\r\n\r\n                # Get currency from Global Defaults\r\n                currency = frappe.db.get_single_value(\"Global Defaults\", \"default_currency\") or \"EGP\"\r\n                item_price.currency = currency\r\n\r\n                # Set valid_from date\r\n                item_price.valid_from = item_data.get(\"custom_repeat_last_updated\") or frappe.utils.now()\r\n\r\n                # Insert with permission bypass (system operation)\r\n                item_price.flags.ignore_permissions = True\r\n                item_price.insert()\r\n\r\n                # Track for logging\r\n                auto_synced_items.append(f\"{item_code} ({final_rate_price})\")\r\n\r\n        except Exception as e:\r\n            # Log error but don't block PO save\r\n            frappe.log_error(\r\n                f\"Failed to auto-create Standard Buying price for {item_code}: {str(e)}\",\r\n                \"PO Auto-Sync Error\"\r\n            )\r\n\r\n# Add comment to PO if items were auto-synced\r\nif auto_synced_items:\r\n    doc.add_comment(\r\n        \"Info\",\r\n        f\"Auto-created Standard Buying prices for: {', '.join(auto_synced_items[:5])}\" +\r\n        (f\" and {len(auto_synced_items) - 5} more\" if len(auto_synced_items) > 5 else \"\")\r\n    )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.721348",
  "module": "Electro Zone",
  "name": "Purchase Order - Price Edit Status Sync",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Purchase Order",
  "script": "# Purchase Order - Price Edit Status Sync (ERPNext v15.8+)\r\n# Purpose:\r\n# - Update Price Edit Status field\r\n# - Runs AFTER \"Fetch From\" operations\r\n# Event: Before Save\r\n# Note: In Server Scripts, `frappe` is already available—no import needed.\r\n\r\nif not doc.items:\r\n    doc.custom_price_edit_status = \"Automatic\"\r\nelse:\r\n    # Check if ANY item has manual edit enabled\r\n    has_manual_edit = False\r\n    for item in doc.items:\r\n        if item.custom_allow_manual_price_edit == 1:\r\n            has_manual_edit = True\r\n            break\r\n\r\n    # Set status based on result\r\n    if has_manual_edit:\r\n        doc.custom_price_edit_status = \"Manually Edited\"\r\n    else:\r\n        doc.custom_price_edit_status = \"Automatic\"",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.701519",
  "module": "Electro Zone",
  "name": "Delivery Note - Update Item Stock Fields",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Delivery Note",
  "script": "# Delivery Note - Update Item Stock Fields\r\n# Purpose: Update Item warehouse stock fields after Delivery Note submission\r\n# Trigger: After Submit (runs after stock is shipped and Bin table updated)\r\n\r\n# Define warehouse mappings (field_name: warehouse_name)\r\nwarehouse_fields = {\r\n    \"custom_stock_store_display\": \"Store Display - EZ\",\r\n    \"custom_stock_store_warehouse\": \"Store Warehouse - EZ\",\r\n    \"custom_stock_damage\": \"Damage - EZ\",\r\n    \"custom_stock_damage_for_sale\": \"Damage For Sale - EZ\",\r\n    \"custom_stock_zahran_main\": \"Zahran Main - EZ\",\r\n    \"custom_stock_hold\": \"Hold (Reserved / Pending Shipment) - EZ\"\r\n}\r\n\r\n# Get all unique item codes from this delivery note\r\nitem_codes = set()\r\nfor item in doc.items:\r\n    if item.item_code:\r\n        item_codes.add(item.item_code)\r\n\r\n# Update stock fields for each item\r\nfor item_code in item_codes:\r\n    if frappe.db.exists(\"Item\", item_code):\r\n        for field_name, warehouse_name in warehouse_fields.items():\r\n            bin_data = frappe.db.sql(\"\"\"\r\n                SELECT actual_qty\r\n                FROM `tabBin`\r\n                WHERE item_code = %s AND warehouse = %s\r\n            \"\"\", (item_code, warehouse_name), as_dict=1)\r\n\r\n            actual_qty = bin_data[0].actual_qty if bin_data else 0\r\n            frappe.db.set_value(\"Item\", item_code, field_name, actual_qty, update_modified=False)\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.728162",
  "module": "Electro Zone",
  "name": "Purchase Receipt - Update Item Stock Fields",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Purchase Receipt",
  "script": "# Purchase Receipt - Update Item Stock Fields\r\n# Purpose: Update Item warehouse stock fields after Purchase Receipt submission\r\n# Trigger: After Submit (runs after stock is received and Bin table updated)\r\n\r\n# Define warehouse mappings (field_name: warehouse_name)\r\nwarehouse_fields = {\r\n    \"custom_stock_store_display\": \"Store Display - EZ\",\r\n    \"custom_stock_store_warehouse\": \"Store Warehouse - EZ\",\r\n    \"custom_stock_damage\": \"Damage - EZ\",\r\n    \"custom_stock_damage_for_sale\": \"Damage For Sale - EZ\",\r\n    \"custom_stock_zahran_main\": \"Zahran Main - EZ\",\r\n    \"custom_stock_hold\": \"Hold (Reserved / Pending Shipment) - EZ\"\r\n}\r\n\r\n# Get all unique item codes from this purchase receipt\r\nitem_codes = set()\r\nfor item in doc.items:\r\n    if item.item_code:\r\n        item_codes.add(item.item_code)\r\n\r\n# Update stock fields for each item\r\nfor item_code in item_codes:\r\n    if frappe.db.exists(\"Item\", item_code):\r\n        for field_name, warehouse_name in warehouse_fields.items():\r\n            bin_data = frappe.db.sql(\"\"\"\r\n                SELECT actual_qty\r\n                FROM `tabBin`\r\n                WHERE item_code = %s AND warehouse = %s\r\n            \"\"\", (item_code, warehouse_name), as_dict=1)\r\n\r\n            actual_qty = bin_data[0].actual_qty if bin_data else 0\r\n            frappe.db.set_value(\"Item\", item_code, field_name, actual_qty, update_modified=False)\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.765304",
  "module": "Electro Zone",
  "name": "Stock Entry - Update Item Stock Fields",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Stock Entry",
  "script": "# Stock Entry - Update Item Stock Fields\r\n# Purpose: Update Item warehouse stock fields after Stock Entry submission\r\n# Trigger: After Submit (runs after ALL ledger entries and Bin updates are committed)\r\n# FIX: Ensures both source AND target warehouses show correct quantities in transfers\r\n\r\n# Define warehouse mappings (field_name: warehouse_name)\r\nwarehouse_fields = {\r\n    \"custom_stock_store_display\": \"Store Display - EZ\",\r\n    \"custom_stock_store_warehouse\": \"Store Warehouse - EZ\",\r\n    \"custom_stock_damage\": \"Damage - EZ\",\r\n    \"custom_stock_damage_for_sale\": \"Damage For Sale - EZ\",\r\n    \"custom_stock_zahran_main\": \"Zahran Main - EZ\",\r\n    \"custom_stock_hold\": \"Hold (Reserved / Pending Shipment) - EZ\"\r\n}\r\n\r\n# Get all unique item codes from this stock entry\r\nitem_codes = set()\r\nfor item in doc.items:\r\n    if item.item_code:\r\n        item_codes.add(item.item_code)\r\n\r\n# Update stock fields for each item in this transaction\r\nfor item_code in item_codes:\r\n    if frappe.db.exists(\"Item\", item_code):\r\n        # Update each warehouse field with current stock\r\n        for field_name, warehouse_name in warehouse_fields.items():\r\n            # Get CURRENT actual qty from Bin table (after commit)\r\n            bin_data = frappe.db.sql(\"\"\"\r\n                SELECT actual_qty\r\n                FROM `tabBin`\r\n                WHERE item_code = %s AND warehouse = %s\r\n            \"\"\", (item_code, warehouse_name), as_dict=1)\r\n\r\n            actual_qty = bin_data[0].actual_qty if bin_data else 0\r\n\r\n            # Update Item field directly in database\r\n            frappe.db.set_value(\"Item\", item_code, field_name, actual_qty, update_modified=False)\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.725912",
  "module": "Electro Zone",
  "name": "Purchase Receipt - Strict PO Validation",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Purchase Receipt",
  "script": "# Purchase Receipt - Strict PO Validation (ALL USERS)\r\n# Purpose:\r\n# - Block PR creation without Purchase Order reference\r\n# - Ensure all items in PR exist in the linked Purchase Order\r\n# - Apply to ALL users (no exceptions)\r\n# Event: Before Save\r\n\r\n# Validation 1: Check if ANY items have Purchase Order reference\r\nhas_po_reference = False\r\nfor item in doc.items:\r\n    if item.purchase_order:\r\n        has_po_reference = True\r\n        break\r\n\r\nif not has_po_reference:\r\n    frappe.throw(\r\n        \"Purchase Receipt cannot be created without a Purchase Order reference. \"\r\n        \"Please create Purchase Receipt from an existing Purchase Order.\"\r\n    )\r\n\r\n# Validation 2: Verify each item exists in its linked Purchase Order\r\nfor item in doc.items:\r\n    if not item.purchase_order:\r\n        frappe.throw(\r\n            f\"Row #{item.idx}: Item {item.item_code} does not have a Purchase Order reference. \"\r\n            f\"All items must be from an existing Purchase Order.\"\r\n        )\r\n\r\n    # Check if item exists in the linked Purchase Order\r\n    po_item_exists = frappe.db.exists(\"Purchase Order Item\", {\r\n        \"parent\": item.purchase_order,\r\n        \"item_code\": item.item_code\r\n    })\r\n\r\n    if not po_item_exists:\r\n        frappe.throw(\r\n            f\"Row #{item.idx}: Item {item.item_code} is not in the linked Purchase Order {item.purchase_order}. \"\r\n            f\"Only items from the Purchase Order can be received.\"\r\n        )\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.753358",
  "module": "Electro Zone",
  "name": "Sales Order - Discount Validation",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# Sales Order - Discount Validation\r\n# Purpose: Validate discount_value against business rules and Item.valuation_rate\r\n# Event: Before Save\r\n# RestrictedPython: Compliant (no +=, no return, no import)\r\n# Modified: Added valuation rate check with simple error message (does not reveal cost)\r\n\r\n# Validate each item in Sales Order\r\nfor item in doc.items:\r\n    # Get discount value (default to 0 if None)\r\n    discount_value = item.custom_discount_value or 0\r\n\r\n    # ─────────────────────────────────────────────────────────\r\n    # VALIDATION 1: Prevent Discount > Rate\r\n    # ─────────────────────────────────────────────────────────\r\n    if discount_value > item.rate:\r\n        frappe.throw(\r\n            f\"\"\"Row {item.idx}: Item {item.item_code}\r\n\r\nDiscount Value ({discount_value:,.2f}) cannot exceed Rate ({item.rate:,.2f}).\r\nPlease reduce the discount value.\r\n            \"\"\",\r\n            title=\"Discount Exceeds Rate\"\r\n        )\r\n\r\n    # ─────────────────────────────────────────────────────────\r\n    # VALIDATION 2: Check Against Valuation Rate\r\n    # ─────────────────────────────────────────────────────────\r\n    # Purpose: Ensure minimum margin is maintained\r\n    # Note: Error message intentionally simple - does NOT reveal valuation_rate value\r\n    # This prevents exposing cost information to Stock Users and restricted roles\r\n\r\n    # Get Item's valuation_rate from master\r\n    valuation_rate = frappe.db.get_value(\r\n        \"Item\",\r\n        item.item_code,\r\n        \"valuation_rate\"\r\n    ) or 0\r\n\r\n    # Calculate effective rate after discount\r\n    effective_rate = item.rate - discount_value\r\n\r\n    # Validate: effective_rate must be >= valuation_rate\r\n    if effective_rate < valuation_rate:\r\n        frappe.throw(\r\n            f\"Row {item.idx}: Item {item.item_code} - Discount not allowed\",\r\n            title=\"Discount Validation Failed\"\r\n        )\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.762156",
  "module": "Electro Zone",
  "name": "Sales Order - Recalculate Amount",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# Sales Order - Recalculate Amount\r\n# Purpose: Server-side backup for amount calculation (Client Script may not fire in API calls)\r\n# Event: Before Save\r\n# Formula: amount = qty × (rate - discount_value)\r\n\r\n# Recalculate amount for each item\r\nfor item in doc.items:\r\n    # Get discount value (default to 0 if None)\r\n    discount_value = item.custom_discount_value or 0\r\n\r\n    # Calculate effective rate\r\n    effective_rate = item.rate - discount_value\r\n\r\n    # Calculate amount: qty × effective_rate\r\n    # Use explicit assignment (no augmented assignment in RestrictedPython)\r\n    item.amount = item.qty * effective_rate\r\n\r\n    # Optional: Log for debugging (comment out in production)\r\n    # frappe.log_error(\r\n    #     f\"Amount recalculated: Item {item.item_code}, Qty {item.qty}, Rate {item.rate}, Discount {discount_value}, Amount {item.amount}\",\r\n    #     \"Sales Order Amount Calculation\"\r\n    # )\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "recalculate_customer_balance",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.678390",
  "module": "Electro Zone",
  "name": "Recalculate Customer Balance",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# Recalculate Customer Balance API\r\n# Purpose: Recalculate customer balances from ledger entries\r\n# Method: recalculate_customer_balance\r\n# Parameters: customer (optional - if blank, recalc all)\r\n\r\n# Get parameters from API call\r\ncustomer = frappe.form_dict.get(\"customer\")\r\n\r\n# Determine which customers to recalculate\r\nif customer:\r\n    # Single customer specified\r\n    customers = [customer]\r\nelse:\r\n    # Recalculate ALL customers with ledger entries\r\n    customers = frappe.db.sql(\"\"\"\r\n        SELECT DISTINCT customer\r\n        FROM `tabCustomer Balance Ledger`\r\n        ORDER BY customer\r\n    \"\"\", as_dict=0)\r\n    customers = [c[0] for c in customers]  # Extract customer names from tuples\r\n\r\nupdated_count = 0\r\nerror_count = 0\r\nerror_customers = []\r\n\r\n# Process each customer\r\nfor cust in customers:\r\n    try:\r\n        # Get all ledger entries for this customer (chronological order)\r\n        ledger_entries = frappe.db.get_all(\r\n            \"Customer Balance Ledger\",\r\n            filters={\"customer\": cust},\r\n            fields=[\"name\", \"debit_amount\", \"credit_amount\", \"transaction_date\", \"creation\"],\r\n            order_by=\"transaction_date asc, creation asc\"\r\n        )\r\n        \r\n        # Calculate running balance from scratch\r\n        running_balance = 0.0\r\n        \r\n        for entry in ledger_entries:\r\n            # Calculate new running balance\r\n            # CORRECTED: Credit increases balance (money owed to us)\r\n            #           Debit decreases balance (payments received)\r\n            running_balance = running_balance + entry.credit_amount - entry.debit_amount\r\n            \r\n            # Update ledger entry running_balance field\r\n            frappe.db.set_value(\r\n                \"Customer Balance Ledger\",\r\n                entry.name,\r\n                \"running_balance\",\r\n                running_balance,\r\n                update_modified=False\r\n            )\r\n        \r\n        # Update customer balance (final running balance)\r\n        frappe.db.set_value(\r\n            \"Customer\",\r\n            cust,\r\n            \"custom_current_balance\",\r\n            running_balance,\r\n            update_modified=False\r\n        )\r\n        \r\n        updated_count = updated_count + 1\r\n        \r\n    except Exception as e:\r\n        error_count = error_count + 1\r\n        error_customers.append(cust)\r\n        frappe.log_error(\r\n            \"Recalculation failed for customer %s: %s\" % (cust, str(e)),\r\n            \"Customer Balance Recalculation Error\"\r\n        )\r\n\r\n# Prepare response\r\nif error_count > 0:\r\n    frappe.response[\"message\"] = {\r\n        \"success\": False,\r\n        \"updated_count\": updated_count,\r\n        \"error_count\": error_count,\r\n        \"error_customers\": error_customers,\r\n        \"message\": \"Recalculated %s customers, but %s failed. Check Error Log.\" % (updated_count, error_count)\r\n    }\r\nelse:\r\n    frappe.response[\"message\"] = {\r\n        \"success\": True,\r\n        \"updated_count\": updated_count,\r\n        \"error_count\": 0,\r\n        \"message\": \"Successfully recalculated balances for %s customers.\" % updated_count\r\n    }",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.704626",
  "module": "Electro Zone",
  "name": "Delivery Note - Validate Sales Order Reference",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Delivery Note",
  "script": "# Delivery Note - Validate Sales Order Reference\r\n# Event: Before Submit\r\n# Purpose: Ensure DN cannot be submitted without Sales Order reference\r\n\r\n# Check if any item has Sales Order reference\r\nhas_so_reference = False\r\nfor item in doc.items:\r\n    if item.against_sales_order:\r\n        has_so_reference = True\r\n        break\r\n\r\n# Block submission if no SO reference found\r\nif not has_so_reference:\r\n    frappe.throw(\r\n        \"Cannot submit Delivery Note without Sales Order reference. \"\r\n        \"All items must be linked to a Sales Order.<br><br>\"\r\n        \"Please create Delivery Note from a Sales Order instead.\",\r\n        title=\"Sales Order Required\"\r\n    )\r\n# If SO reference found, validation passes (no action needed)\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.680689",
  "module": "Electro Zone",
  "name": "Customer - Validate Phone Uniqueness",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Customer",
  "script": "# Customer - Validate Primary Address Phone Uniqueness (Before Save)\r\n# Purpose: Ensures no two customers have the same phone on their primary address\r\n# Pattern: Address-based uniqueness validation (aligns with Phase 14.1)\r\n\r\n# STEP 1: Validate customer has a primary address\r\nprimary_address = doc.get('customer_primary_address')\r\n\r\nif not primary_address:\r\n    frappe.throw(\r\n        \"Customer must have a Primary Address.<br><br>\"\r\n        \"Please create an Address and link it as the Primary Address for this customer.\",\r\n        title=\"Primary Address Required\"\r\n    )\r\n\r\n# STEP 2: Get phone from the linked Address\r\nphone = frappe.db.get_value(\"Address\", primary_address, \"phone\")\r\n\r\nif not phone:\r\n    frappe.throw(\r\n        f\"The Primary Address ({primary_address}) does not have a phone number.<br><br>\"\r\n        f\"Please add a phone number to the Address before saving this customer.\",\r\n        title=\"Phone Number Required on Address\"\r\n    )\r\n\r\n# STEP 3: Remove spaces and formatting for consistent comparison\r\nphone_clean = phone.replace(\" \", \"\").replace(\"-\", \"\").replace(\"(\", \"\").replace(\")\", \"\")\r\n\r\n# STEP 4: Validate phone format (basic check)\r\nif len(phone_clean) < 10:\r\n    frappe.throw(\r\n        f\"Phone Number '{phone}' appears to be invalid.<br><br>\"\r\n        f\"Phone numbers must have at least 10 digits.\",\r\n        title=\"Invalid Phone Number\"\r\n    )\r\n\r\n# STEP 5: Check if another customer's primary address has the same phone\r\n# Find all addresses with this phone number\r\naddresses_with_phone = frappe.db.get_all(\"Address\",\r\n    filters={\"phone\": phone},\r\n    fields=[\"name\"]\r\n)\r\n\r\nif addresses_with_phone:\r\n    # Check if any of these addresses are primary for OTHER customers\r\n    for addr in addresses_with_phone:\r\n        other_customer = frappe.db.get_value(\"Customer\",\r\n            filters={\r\n                \"customer_primary_address\": addr.name,\r\n                \"name\": [\"!=\", doc.name]  # Exclude current customer (for updates)\r\n            },\r\n            fieldname=[\"name\", \"customer_name\"],\r\n            as_dict=1\r\n        )\r\n\r\n        if other_customer:\r\n            frappe.throw(\r\n                f\"Phone Number '{phone}' is already in use.<br><br>\"\r\n                f\"<b>Existing Customer:</b> {other_customer.customer_name} ({other_customer.name})<br>\"\r\n                f\"<b>Primary Address:</b> {addr.name}<br><br>\"\r\n                f\"Each customer must have a unique phone number on their primary address. \"\r\n                f\"Please use a different phone number or update the existing customer record.\",\r\n                title=\"Duplicate Phone Number\"\r\n            )\r\n\r\n# STEP 6: Success - validation passed\r\nfrappe.msgprint(\r\n    f\"✓ Phone number '{phone}' validated successfully on Primary Address ({primary_address})\",\r\n    alert=True\r\n)\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Cancel",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.763737",
  "module": "Electro Zone",
  "name": "Sales Order - Validate Cancellation",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# Sales Order - Validate Cancellation (Prevent Cascade)\r\n# Event: Before Cancel\r\n# Purpose: Block cancellation if ANY SI or DN records exist (prevents cascade cancellation)\r\n# Phase: 16 - SO Cancellation with DN Validation\r\n\r\n# ============================================================\r\n# CRITICAL: Check for ANY linked Sales Invoice Items\r\n# ============================================================\r\n# We check for Sales Invoice Items, not Sales Invoices, because:\r\n# 1. More reliable - directly linked to SO\r\n# 2. Catches all invoices, even if parent is deleted\r\n# 3. Prevents cascade cancellation bypass\r\n\r\nsi_items = frappe.db.get_all(\r\n    \"Sales Invoice Item\",\r\n    filters={\r\n        \"sales_order\": doc.name\r\n    },\r\n    fields=[\"parent\"],\r\n    limit=1\r\n)\r\n\r\nif si_items:\r\n    # Get the Sales Invoice details\r\n    si_name = si_items[0].parent\r\n    si_doc = frappe.db.get_value(\r\n        \"Sales Invoice\",\r\n        si_name,\r\n        [\"name\", \"docstatus\", \"posting_date\", \"grand_total\"],\r\n        as_dict=True\r\n    )\r\n\r\n    if si_doc:\r\n        status_text = \"Submitted\" if si_doc.docstatus == 1 else \"Cancelled\" if si_doc.docstatus == 2 else \"Draft\"\r\n\r\n        frappe.throw(\r\n            \"Cannot cancel Sales Order. A Sales Invoice is linked to this order:<br><br>\"\r\n            \"• <b>%s</b> (Status: %s)<br><br>\"\r\n            \"<b>Why this is blocked:</b><br>\"\r\n            \"This Sales Order has a linked Sales Invoice. ERPNext's cascade cancellation \"\r\n            \"attempts to cancel all linked documents automatically, which causes:<br>\"\r\n            \"• Incorrect balance restoration order<br>\"\r\n            \"• Accounting inconsistencies<br>\"\r\n            \"• Stock return errors<br><br>\"\r\n            \"<b>Correct Process:</b><br>\"\r\n            \"1. Manually cancel the Sales Invoice: <b>%s</b><br>\"\r\n            \"2. Wait for balance restoration to complete<br>\"\r\n            \"3. Then cancel this Sales Order<br><br>\"\r\n            \"<b>Note:</b> You MUST follow this sequence. There is no shortcut.\" % (\r\n                si_doc.name,\r\n                status_text,\r\n                si_doc.name\r\n            ),\r\n            title=\"Cancellation Blocked - Invoice Linked\"\r\n        )\r\n\r\n# ============================================================\r\n# IMPROVED: Check DN Workflow State (allow Pending Dispatch only)\r\n# ============================================================\r\n# Pending Dispatch DNs will be auto-cancelled in After Cancel script\r\n# Block cancellation if DN is Out for Delivery or Delivered\r\n\r\ndn_items = frappe.db.get_all(\r\n    \"Delivery Note Item\",\r\n    filters={\r\n        \"against_sales_order\": doc.name\r\n    },\r\n    fields=[\"parent\"],\r\n    distinct=True\r\n)\r\n\r\nif dn_items:\r\n    # Get unique DN names\r\n    dn_names = [item.parent for item in dn_items]\r\n\r\n    # Get all linked DNs with their workflow states\r\n    all_dns = frappe.db.get_all(\r\n        \"Delivery Note\",\r\n        filters={\r\n            \"name\": [\"in\", dn_names]\r\n        },\r\n        fields=[\"name\", \"docstatus\", \"workflow_state\", \"posting_date\", \"grand_total\"]\r\n    )\r\n\r\n    for dn in all_dns:\r\n        dn_workflow_state = dn.get(\"workflow_state\", \"\")\r\n        dn_docstatus = dn.get(\"docstatus\", 0)\r\n\r\n        # STRICT RULE: ONLY allow cancellation if workflow_state is EXACTLY \"Pending Dispatch\"\r\n        # Block everything else (Out for Delivery, Delivered, Return, Cancelled, or no workflow_state)\r\n\r\n        if dn_workflow_state != \"Pending Dispatch\":\r\n            # Block cancellation - DN is NOT in Pending Dispatch state\r\n\r\n            # Show appropriate error message based on status\r\n            if dn_docstatus == 2:\r\n                # DN is already cancelled - still block (shouldn't happen but handle gracefully)\r\n                status_display = \"Cancelled\"\r\n            elif dn_docstatus == 1:\r\n                # DN is submitted (Out for Delivery, Delivered, etc.)\r\n                status_display = dn_workflow_state or \"Submitted\"\r\n            else:\r\n                # DN is Draft but not in Pending Dispatch\r\n                status_display = dn_workflow_state or \"Draft\"\r\n\r\n            frappe.throw(\r\n                \"Cannot cancel Sales Order. Delivery Note must be in <b>Pending Dispatch</b> status.<br><br>\"\r\n                \"• Delivery Note: <b>%s</b><br>\"\r\n                \"• Current Status: <b>%s</b><br>\"\r\n                \"• docstatus: %s<br><br>\"\r\n                \"<b>Why this is blocked:</b><br>\"\r\n                \"Sales Orders can ONLY be cancelled if the Delivery Note is in <b>Pending Dispatch</b> status.<br><br>\"\r\n                \"<b>Current workflow_state: '%s'</b><br><br>\"\r\n                \"<b>Options:</b><br>\"\r\n                \"1. If DN is submitted: Cancel the Delivery Note first, then cancel this Sales Order<br>\"\r\n                \"2. If DN is in wrong state: Contact administrator<br><br>\"\r\n                \"<b>Allowed:</b> workflow_state = 'Pending Dispatch' only\" % (\r\n                    dn.name,\r\n                    status_display,\r\n                    dn_docstatus,\r\n                    dn_workflow_state or \"(empty)\"\r\n                ),\r\n                title=\"Cancellation Blocked - DN Not in Pending Dispatch\"\r\n            )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.715598",
  "module": "Electro Zone",
  "name": "Payment Entry - Balance Top-Up and Refund Handler",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Payment Entry",
  "script": "# Payment Entry - Balance Top-Up and Refund Handler\r\n# Event: After Submit\r\n# Purpose: Update customer balance when payment received OR refund paid to customer\r\n\r\n# Validate party type is Customer (for both Receive and Pay)\r\nif doc.party_type != \"Customer\":\r\n    # Not a customer transaction - skip processing\r\n    pass\r\nelse:\r\n        # Get customer and payment amount\r\n        customer = doc.party\r\n        payment_amount = doc.paid_amount\r\n\r\n        # Validate customer exists\r\n        if not customer:\r\n            frappe.log_error(\"No customer found on Payment Entry %s\" % doc.name, \"Customer Balance Error\")\r\n        else:\r\n            # Get current balance\r\n            current_balance = frappe.db.get_value(\"Customer\", customer, \"custom_current_balance\") or 0.0\r\n\r\n            # Validate customer has primary address with phone (Phase 14.12)\r\n            primary_address = frappe.db.get_value(\"Customer\", customer, \"customer_primary_address\")\r\n            if not primary_address:\r\n                frappe.throw(\r\n                    \"Customer %s does not have a primary address. Please set primary address in Customer master before creating payments.\" % customer,\r\n                    title=\"Primary Address Required\"\r\n                )\r\n\r\n            phone = frappe.db.get_value(\"Address\", primary_address, \"phone\")\r\n            if not phone:\r\n                frappe.throw(\r\n                    \"Primary address for customer %s does not have a phone number. Please add phone to address before creating payments.\" % customer,\r\n                    title=\"Phone Number Required\"\r\n                )\r\n\r\n            # Check if ledger entry already exists (prevent duplicates)\r\n            existing_ledger = frappe.db.exists(\"Customer Balance Ledger\", {\r\n                \"reference_doctype\": \"Payment Entry\",\r\n                \"reference_document\": doc.name,\r\n                \"customer\": customer\r\n            })\r\n\r\n            if existing_ledger:\r\n                # Already processed - skip to avoid duplicate\r\n                frappe.log_error(\r\n                    \"Ledger entry already exists for Payment Entry %s - skipping duplicate\" % doc.name,\r\n                    \"Customer Balance - Duplicate Prevention\"\r\n                )\r\n            else:\r\n                # Check if this is auto-created from SO (skip balance update)\r\n                auto_created = frappe.get_all(\r\n                    \"Comment\",\r\n                    filters={\r\n                        \"reference_doctype\": \"Payment Entry\",\r\n                        \"reference_name\": doc.name,\r\n                        \"content\": \"AUTO_CREATED_FROM_SO_BALANCE_DO_NOT_UPDATE_BALANCE\"\r\n                    },\r\n                    limit=1\r\n                )\r\n\r\n                if len(auto_created) > 0:\r\n                    # Skip balance update - already done by SO script\r\n                    frappe.msgprint(\r\n                        \"Auto-created PE from SO balance. Balance already updated.\",\r\n                        indicator=\"blue\"\r\n                    )\r\n                else:\r\n                    # Regular Payment Entry - process balance update\r\n                    # Determine payment direction and calculate balance\r\n                    if doc.payment_type == \"Receive\":\r\n                        # Customer paying us - increase balance (customer has credit)\r\n                        new_balance = current_balance + payment_amount\r\n                        debit_amt = 0.0\r\n                        credit_amt = payment_amount\r\n                        payment_mode = doc.mode_of_payment or \"Cash\"\r\n                        remarks = \"Payment %s - %s\" % (doc.name, payment_mode)\r\n\r\n                        # Create ledger entry\r\n                        ledger = frappe.new_doc(\"Customer Balance Ledger\")\r\n                        ledger.transaction_date = doc.posting_date\r\n                        ledger.posting_time = doc.posting_time or frappe.utils.nowtime()\r\n                        ledger.customer = customer\r\n                        ledger.customer_name = doc.party_name\r\n                        ledger.reference_doctype = \"Payment Entry\"\r\n                        ledger.reference_document = doc.name\r\n                        ledger.reference_date = doc.posting_date\r\n                        ledger.debit_amount = debit_amt\r\n                        ledger.credit_amount = credit_amt\r\n                        ledger.balance_before = current_balance\r\n                        ledger.running_balance = new_balance\r\n                        ledger.remarks = remarks\r\n                        ledger.company = doc.company\r\n                        ledger.created_by = frappe.session.user\r\n\r\n                        # Set phone from address\r\n                        if phone:\r\n                            ledger.phone = phone\r\n                        if primary_address:\r\n                            ledger.customer_primary_address = primary_address\r\n\r\n                        ledger.insert(ignore_permissions=True)\r\n\r\n                        # Update customer balance\r\n                        frappe.db.set_value(\"Customer\", customer, \"custom_current_balance\", new_balance, update_modified=False)\r\n\r\n                        frappe.msgprint(\r\n                            \"Payment recorded. Customer balance updated to <b>%s</b>\" % frappe.format_value(new_balance, {\"fieldtype\": \"Currency\"}),\r\n                            indicator=\"green\",\r\n                            title=\"Balance Updated\"\r\n                        )\r\n\r\n                    elif doc.payment_type == \"Pay\":\r\n                        # We're paying customer back (refund) - decrease credit balance\r\n\r\n                        # INFO: Show current balance for reference (no blocking)\r\n                        if current_balance <= 0:\r\n                            frappe.msgprint(\r\n                                \"ℹ️ Customer has no credit balance.<br><br>\"\r\n                                \"Current balance: <b>%s</b><br><br>\"\r\n                                \"Refund will create a negative balance (amount owed to customer).\" % (\r\n                                    frappe.format_value(current_balance, {\"fieldtype\": \"Currency\"})\r\n                                ),\r\n                                indicator=\"blue\",\r\n                                title=\"Balance Information\"\r\n                            )\r\n                        elif payment_amount > current_balance:\r\n                            frappe.msgprint(\r\n                                \"ℹ️ Refund amount <b>%s</b> exceeds customer credit balance <b>%s</b><br><br>\"\r\n                                \"Resulting balance will be negative (we owe customer: <b>%s</b>)\" % (\r\n                                    frappe.format_value(payment_amount, {\"fieldtype\": \"Currency\"}),\r\n                                    frappe.format_value(current_balance, {\"fieldtype\": \"Currency\"}),\r\n                                    frappe.format_value(current_balance - payment_amount, {\"fieldtype\": \"Currency\"})\r\n                                ),\r\n                                indicator=\"orange\",\r\n                                title=\"Balance Warning\"\r\n                            )\r\n\r\n                        # Process refund (no validation blocking)\r\n                        new_balance = current_balance - payment_amount\r\n                        debit_amt = payment_amount\r\n                        credit_amt = 0.0\r\n                        payment_mode = doc.mode_of_payment or \"Cash\"\r\n                        remarks = \"Refund %s - %s\" % (doc.name, payment_mode)\r\n\r\n                        # Create ledger entry\r\n                        ledger = frappe.new_doc(\"Customer Balance Ledger\")\r\n                        ledger.transaction_date = doc.posting_date\r\n                        ledger.posting_time = doc.posting_time or frappe.utils.nowtime()\r\n                        ledger.customer = customer\r\n                        ledger.customer_name = doc.party_name\r\n                        ledger.reference_doctype = \"Payment Entry\"\r\n                        ledger.reference_document = doc.name\r\n                        ledger.reference_date = doc.posting_date\r\n                        ledger.debit_amount = debit_amt\r\n                        ledger.credit_amount = credit_amt\r\n                        ledger.balance_before = current_balance\r\n                        ledger.running_balance = new_balance\r\n                        ledger.remarks = remarks\r\n                        ledger.company = doc.company\r\n                        ledger.created_by = frappe.session.user\r\n\r\n                        # Set phone from address\r\n                        if phone:\r\n                            ledger.phone = phone\r\n                        if primary_address:\r\n                            ledger.customer_primary_address = primary_address\r\n\r\n                        ledger.insert(ignore_permissions=True)\r\n\r\n                        # Update customer balance\r\n                        frappe.db.set_value(\"Customer\", customer, \"custom_current_balance\", new_balance, update_modified=False)\r\n\r\n                        frappe.msgprint(\r\n                            \"Refund processed. Customer balance updated to <b>%s</b>\" % frappe.format_value(new_balance, {\"fieldtype\": \"Currency\"}),\r\n                            indicator=\"green\",\r\n                            title=\"Refund Complete\"\r\n                        )\r\n\r\n                        # ============================================\r\n                        # UPDATE SO per_billed AFTER REFUND (NEW - 2025-12-29)\r\n                        # ============================================\r\n                        # When Payment Entry (Pay) is allocated to Credit Notes,\r\n                        # we need to recalculate SO per_billed to reflect the refund\r\n\r\n                        # Track which Sales Orders we've already updated (avoid duplicates)\r\n                        updated_sales_orders = []\r\n\r\n                        # Check all references in this Payment Entry\r\n                        for ref in doc.references:\r\n                            # Only process Sales Invoice references (Credit Notes)\r\n                            if ref.reference_doctype == \"Sales Invoice\":\r\n                                si_name = ref.reference_name\r\n\r\n                                # Check if this is a Credit Note (is_return=1)\r\n                                is_credit_note = frappe.db.get_value(\"Sales Invoice\", si_name, \"is_return\")\r\n\r\n                                if is_credit_note:\r\n                                    # Find Sales Order linked to the ORIGINAL invoice (not the Credit Note itself)\r\n                                    # Credit Note has return_against field pointing to original invoice\r\n                                    original_invoice = frappe.db.get_value(\"Sales Invoice\", si_name, \"return_against\")\r\n\r\n                                    if original_invoice:\r\n                                        # Get SO from original invoice items\r\n                                        sales_order = frappe.db.sql(\"\"\"\r\n                                            SELECT DISTINCT si_item.sales_order\r\n                                            FROM `tabSales Invoice Item` si_item\r\n                                            WHERE si_item.parent = %s\r\n                                            AND si_item.sales_order IS NOT NULL\r\n                                            LIMIT 1\r\n                                        \"\"\", (original_invoice,))\r\n\r\n                                        if sales_order and sales_order[0][0]:\r\n                                            so_name = sales_order[0][0]\r\n\r\n                                            # Skip if we already updated this SO\r\n                                            if so_name in updated_sales_orders:\r\n                                                continue\r\n\r\n                                            # Mark as updated\r\n                                            updated_sales_orders.append(so_name)\r\n\r\n                                            # Recalculate SO billing status\r\n                                            try:\r\n                                                # Get SO details\r\n                                                so_doc = frappe.get_doc(\"Sales Order\", so_name)\r\n                                                so_grand_total = so_doc.grand_total or 0\r\n\r\n                                                # Query 1: Get total invoiced amount for this SO\r\n                                                total_invoiced = frappe.db.sql(\"\"\"\r\n                                                    SELECT IFNULL(SUM(si.grand_total), 0) as total\r\n                                                    FROM `tabSales Invoice` si\r\n                                                    INNER JOIN `tabSales Invoice Item` si_item\r\n                                                        ON si_item.parent = si.name\r\n                                                    WHERE si_item.sales_order = %s\r\n                                                    AND si.docstatus = 1\r\n                                                    AND si.is_return = 0\r\n                                                \"\"\", (so_name,))[0][0] or 0\r\n\r\n                                                # Query 2: Get total outstanding from invoices\r\n                                                total_outstanding = frappe.db.sql(\"\"\"\r\n                                                    SELECT IFNULL(SUM(si.outstanding_amount), 0) as total\r\n                                                    FROM `tabSales Invoice` si\r\n                                                    INNER JOIN `tabSales Invoice Item` si_item\r\n                                                        ON si_item.parent = si.name\r\n                                                    WHERE si_item.sales_order = %s\r\n                                                    AND si.docstatus = 1\r\n                                                    AND si.is_return = 0\r\n                                                \"\"\", (so_name,))[0][0] or 0\r\n\r\n                                                # Query 3: Get total Credit Note amount (returns reduce paid amount)\r\n                                                # CRITICAL: Only count Credit Notes with outstanding = 0 (fully paid/closed)\r\n                                                total_credit_notes = frappe.db.sql(\"\"\"\r\n                                                    SELECT IFNULL(SUM(ABS(si.grand_total)), 0) as total\r\n                                                    FROM `tabSales Invoice` si\r\n                                                    WHERE si.return_against IN (\r\n                                                        SELECT parent FROM `tabSales Invoice Item`\r\n                                                        WHERE sales_order = %s\r\n                                                    )\r\n                                                    AND si.docstatus = 1\r\n                                                    AND si.is_return = 1\r\n                                                    AND si.outstanding_amount = 0\r\n                                                \"\"\", (so_name,))[0][0] or 0\r\n\r\n                                                # Calculate total paid from outstanding (accounting for closed credit notes)\r\n                                                total_paid = total_invoiced - total_outstanding - total_credit_notes\r\n\r\n                                                # Calculate percentages\r\n                                                per_billed = (total_paid / so_grand_total * 100) if so_grand_total > 0 else 0\r\n\r\n                                                # Determine billing_status\r\n                                                if per_billed == 0:\r\n                                                    billing_status = \"Not Paid\"\r\n                                                elif per_billed < 100:\r\n                                                    billing_status = \"Partly Paid\"\r\n                                                else:\r\n                                                    billing_status = \"Fully Paid\"\r\n\r\n                                                # CRITICAL: Check if SO was closed by return workflow\r\n                                                # If custom_is_returned = 1, DO NOT update status (keep it \"Closed\")\r\n                                                is_returned = so_doc.get(\"custom_is_returned\", 0)\r\n\r\n                                                if is_returned == 1:\r\n                                                    # SO is closed due to return - only update per_billed and billing_status\r\n                                                    # DO NOT change status from \"Closed\"\r\n                                                    frappe.db.set_value(\"Sales Order\", so_name, {\r\n                                                        \"per_billed\": per_billed,\r\n                                                        \"billing_status\": billing_status\r\n                                                    }, update_modified=False)\r\n\r\n                                                    frappe.msgprint(\r\n                                                        \"Refund processed for returned SO <b>%s</b>:<br>\"\r\n                                                        \"• Status remains: <b>Closed</b> (return workflow)<br>\"\r\n                                                        \"• Paid (net after refund): <b>%.2f%%</b><br>\"\r\n                                                        \"• Payment Status: <b>%s</b>\" % (\r\n                                                            so_name,\r\n                                                            per_billed,\r\n                                                            billing_status\r\n                                                        ),\r\n                                                        indicator=\"blue\",\r\n                                                        title=\"Refund Processed\"\r\n                                                    )\r\n                                                else:\r\n                                                    # Normal SO - update status based on delivery and billing\r\n                                                    per_delivered = so_doc.per_delivered or 0\r\n\r\n                                                    # Determine overall SO status\r\n                                                    if per_billed >= 100 and per_delivered >= 100:\r\n                                                        so_status = \"Completed\"\r\n                                                    elif per_delivered >= 100 and per_billed < 100:\r\n                                                        so_status = \"To Bill\"\r\n                                                    elif per_billed >= 100 and per_delivered < 100:\r\n                                                        so_status = \"To Deliver\"\r\n                                                    else:\r\n                                                        so_status = \"To Deliver and Bill\"\r\n\r\n                                                    # Update Sales Order\r\n                                                    frappe.db.set_value(\"Sales Order\", so_name, {\r\n                                                        \"per_billed\": per_billed,\r\n                                                        \"billing_status\": billing_status,\r\n                                                        \"status\": so_status\r\n                                                    }, update_modified=False)\r\n\r\n                                                    # Determine indicator color\r\n                                                    msg_indicator = \"green\" if per_billed >= 100 else (\"orange\" if per_billed > 0 else \"blue\")\r\n\r\n                                                    frappe.msgprint(\r\n                                                        \"Refund processed. Sales Order <b>%s</b> status updated:<br>\"\r\n                                                        \"• Delivered: <b>%.2f%%</b><br>\"\r\n                                                        \"• Paid (net after refund): <b>%.2f%%</b><br>\"\r\n                                                        \"• Payment Status: <b>%s</b><br>\"\r\n                                                        \"• Overall Status: <b>%s</b>\" % (\r\n                                                            so_name,\r\n                                                            per_delivered,\r\n                                                            per_billed,\r\n                                                            billing_status,\r\n                                                            so_status\r\n                                                        ),\r\n                                                        indicator=msg_indicator,\r\n                                                        title=\"SO Updated After Refund\"\r\n                                                    )\r\n\r\n                                            except Exception as e:\r\n                                                frappe.log_error(\r\n                                                    \"Failed to update SO billing status for %s after refund: %s\" % (so_name, str(e)),\r\n                                                    \"PE Refund SO Update Error\"\r\n                                                )\r\n                                                # Don't throw error - refund was successful\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Save (Submitted Document)",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.706043",
  "module": "Electro Zone",
  "name": "Delivery Note - Workflow State Change Handler",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Delivery Note",
  "script": "# Delivery Note - Workflow State Change Handler\r\n# Event: After Save (Submitted Document)\r\n# Purpose: Handle workflow state changes (Delivered, Delivery Failed, Auto-close SO on Return)\r\n\r\n# Get old workflow state to detect changes\r\nold_state = frappe.db.get_value(\"Delivery Note\", doc.name, \"workflow_state\")\r\n\r\n# ========================================\r\n# CASE 1: Delivery Successful (state = \"Delivered\")\r\n# ========================================\r\nif doc.workflow_state == \"Delivered\" and old_state != \"Delivered\":\r\n    # VALIDATION: Check customer balance >= 0 (fully paid)\r\n    customer_balance = frappe.db.get_value(\"Customer\", doc.customer, \"custom_current_balance\") or 0.0\r\n\r\n    if customer_balance < 0:\r\n        frappe.throw(\r\n            \"Cannot mark as Delivered. Customer has outstanding balance of <b>%s</b>.<br><br>\"\r\n            \"<b>Action Required:</b><br>\"\r\n            \"1. Collect payment from customer<br>\"\r\n            \"2. Create Payment Entry<br>\"\r\n            \"3. Then mark as Delivered\" % frappe.format_value(abs(customer_balance), {\"fieldtype\": \"Currency\"}),\r\n            title=\"Payment Required\"\r\n        )\r\n\r\n    # Check if SI already exists (prevent duplicates)\r\n    existing_si = frappe.db.exists(\"Sales Invoice Item\", {\r\n        \"delivery_note\": doc.name,\r\n        \"docstatus\": 1\r\n    })\r\n\r\n    if existing_si:\r\n        frappe.msgprint(\r\n            \"Sales Invoice already exists for this Delivery Note.\",\r\n            indicator=\"blue\",\r\n            title=\"Already Processed\"\r\n        )\r\n    else:\r\n        # Create Sales Invoice\r\n        try:\r\n            si = frappe.new_doc(\"Sales Invoice\")\r\n\r\n            # Copy header fields\r\n            si.customer = doc.customer\r\n            si.customer_name = doc.customer_name\r\n            si.posting_date = doc.posting_date\r\n            si.posting_time = doc.posting_time\r\n            si.due_date = frappe.utils.add_days(doc.posting_date, 30)\r\n            si.company = doc.company\r\n            si.currency = doc.currency\r\n            si.conversion_rate = doc.conversion_rate or 1.0\r\n\r\n            # Copy price list settings\r\n            if doc.selling_price_list:\r\n                si.selling_price_list = doc.selling_price_list\r\n            if doc.price_list_currency:\r\n                si.price_list_currency = doc.price_list_currency\r\n            if doc.plc_conversion_rate:\r\n                si.plc_conversion_rate = doc.plc_conversion_rate\r\n\r\n            # Copy pricing rule setting\r\n            if doc.get('ignore_pricing_rule') is not None:\r\n                si.ignore_pricing_rule = doc.ignore_pricing_rule\r\n\r\n            # Copy items from DN\r\n            for dn_item in doc.items:\r\n                si.append(\"items\", {\r\n                    \"item_code\": dn_item.item_code,\r\n                    \"item_name\": dn_item.item_name,\r\n                    \"description\": dn_item.description or dn_item.item_name,\r\n                    \"qty\": dn_item.qty,\r\n                    \"uom\": dn_item.uom,\r\n                    \"stock_uom\": dn_item.stock_uom,\r\n                    \"conversion_factor\": dn_item.conversion_factor or 1.0,\r\n                    \"rate\": dn_item.rate,\r\n                    \"amount\": dn_item.amount,\r\n                    \"warehouse\": dn_item.warehouse,\r\n                    \"delivery_note\": doc.name,\r\n                    \"dn_detail\": dn_item.name,\r\n                    \"sales_order\": dn_item.against_sales_order,\r\n                    \"so_detail\": dn_item.so_detail,\r\n                    \"cost_center\": dn_item.cost_center,\r\n                    \"expense_account\": dn_item.expense_account,\r\n                })\r\n\r\n            # Copy taxes if any\r\n            if doc.taxes:\r\n                for tax in doc.taxes:\r\n                    si.append(\"taxes\", {\r\n                        \"charge_type\": tax.charge_type,\r\n                        \"account_head\": tax.account_head,\r\n                        \"description\": tax.description,\r\n                        \"rate\": tax.get('rate', 0),\r\n                        \"tax_amount\": tax.get('tax_amount', 0),\r\n                        \"total\": tax.get('total', 0),\r\n                        \"cost_center\": tax.get('cost_center', None),\r\n                    })\r\n\r\n            # Insert and submit SI\r\n            si.insert(ignore_permissions=True)\r\n            si.submit()\r\n\r\n            # Add comment to DN linking to SI\r\n            doc.add_comment(\r\n                \"Comment\",\r\n                \"Sales Invoice <b>%s</b> created and submitted automatically on delivery confirmation.\" % si.name\r\n            )\r\n\r\n            # Success message with clickable link\r\n            frappe.msgprint(\r\n                \"Delivery confirmed. Sales Invoice <b><a href='/app/sales-invoice/%s'>%s</a></b> created successfully.<br><br>\"\r\n                \"• Invoice amount: <b>%s</b><br>\"\r\n                \"• Auto-allocated from customer balance (if available)\" % (\r\n                    si.name,\r\n                    si.name,\r\n                    frappe.format_value(si.grand_total, {\"fieldtype\": \"Currency\"})\r\n                ),\r\n                indicator=\"green\",\r\n                title=\"Invoice Created\"\r\n            )\r\n\r\n        except Exception as e:\r\n            # Log error but don't block DN state change\r\n            error_message = str(e)\r\n            frappe.log_error(\r\n                \"Failed to auto-create Sales Invoice from DN %s: %s\" % (doc.name, error_message),\r\n                \"Auto SI Creation Error\"\r\n            )\r\n\r\n            # Show user-friendly error message\r\n            frappe.msgprint(\r\n                \"Delivery marked as complete, but Sales Invoice auto-creation failed.<br><br>\"\r\n                \"<b>Error:</b> %s<br><br>\"\r\n                \"Please create Sales Invoice manually from this Delivery Note.\" % error_message,\r\n                indicator=\"red\",\r\n                title=\"Auto-Creation Failed\"\r\n            )\r\n\r\n# ========================================\r\n# CASE 2: Delivery Failed (state = \"Delivery Failed\")\r\n# ========================================\r\nelif doc.workflow_state == \"Delivery Failed\" and old_state != \"Delivery Failed\":\r\n    # Get linked Sales Order\r\n    so_name = frappe.db.get_value(\"Delivery Note Item\", {\"parent\": doc.name}, \"against_sales_order\")\r\n\r\n    if so_name:\r\n        so = frappe.get_doc(\"Sales Order\", so_name)\r\n        advance_paid = so.advance_paid or 0.0\r\n        customer = so.customer\r\n\r\n        # 1. Refund advance_paid to customer balance\r\n        if advance_paid > 0:\r\n            # Get current balance\r\n            current_balance = frappe.db.get_value(\"Customer\", customer, \"custom_current_balance\") or 0.0\r\n\r\n            # Increase balance by advance_paid\r\n            new_balance = current_balance + advance_paid\r\n\r\n            # Update balance\r\n            frappe.db.set_value(\"Customer\", customer, \"custom_current_balance\", new_balance, update_modified=False)\r\n\r\n            # Create ledger entry\r\n            ledger = frappe.new_doc(\"Customer Balance Ledger\")\r\n            ledger.transaction_date = frappe.utils.today()\r\n            ledger.posting_time = frappe.utils.nowtime()\r\n            ledger.customer = customer\r\n            ledger.customer_name = so.customer_name\r\n            ledger.reference_doctype = \"Delivery Note\"\r\n            ledger.reference_document = doc.name\r\n            ledger.reference_date = doc.posting_date\r\n            ledger.debit_amount = 0.0\r\n            ledger.credit_amount = advance_paid\r\n            ledger.balance_before = current_balance\r\n            ledger.running_balance = new_balance\r\n            ledger.remarks = \"Delivery Failed - Advance refunded for SO %s (DN: %s)\" % (so_name, doc.name)\r\n            ledger.company = doc.company\r\n            ledger.created_by = frappe.session.user\r\n\r\n            ledger.insert(ignore_permissions=True)\r\n\r\n        # 2. Return stock to original source warehouse\r\n        source_warehouse = so.get(\"custom_source_warehouse\")\r\n\r\n        if not source_warehouse:\r\n            # Fallback to Zahran Main if not stored\r\n            source_warehouse = \"Zahran Main - EZ\"  # Replace EZ with actual\r\n            frappe.msgprint(\r\n                \"Source warehouse not found on SO. Defaulting to Zahran Main.\",\r\n                indicator=\"blue\",\r\n                title=\"Warehouse Fallback\"\r\n            )\r\n\r\n        hold_warehouse = \"Hold (Reserved / Pending Shipment) - EZ\"  # Replace EZ\r\n\r\n        # Create Stock Entry (Material Transfer: Hold → Source)\r\n        try:\r\n            stock_entry = frappe.new_doc(\"Stock Entry\")\r\n            stock_entry.stock_entry_type = \"Material Transfer\"\r\n            stock_entry.company = doc.company\r\n            stock_entry.posting_date = frappe.utils.today()\r\n            stock_entry.posting_time = frappe.utils.nowtime()\r\n\r\n            for item in doc.items:\r\n                stock_entry.append(\"items\", {\r\n                    \"item_code\": item.item_code,\r\n                    \"item_name\": item.item_name,\r\n                    \"qty\": item.qty,\r\n                    \"s_warehouse\": hold_warehouse,\r\n                    \"t_warehouse\": source_warehouse,\r\n                    \"uom\": item.uom,\r\n                    \"stock_uom\": item.stock_uom,\r\n                    \"conversion_factor\": item.conversion_factor or 1.0\r\n                })\r\n\r\n            stock_entry.insert(ignore_permissions=True)\r\n            stock_entry.submit()\r\n\r\n            # Add comment\r\n            doc.add_comment(\r\n                \"Comment\",\r\n                \"Delivery failed. Stock returned from Hold to %s (Stock Entry: %s)\" % (source_warehouse, stock_entry.name)\r\n            )\r\n\r\n        except Exception as e:\r\n            error_msg = str(e)\r\n            frappe.log_error(\r\n                \"Failed to return stock for failed delivery DN %s: %s\" % (doc.name, error_msg),\r\n                \"Stock Return Error\"\r\n            )\r\n            frappe.msgprint(\r\n                \"Delivery marked as failed but stock return failed:<br>\"\r\n                \"<b>Error:</b> %s<br><br>\"\r\n                \"Please manually create Stock Entry to return stock from Hold to %s.\" % (error_msg, source_warehouse),\r\n                indicator=\"red\",\r\n                title=\"Stock Return Failed\"\r\n            )\r\n\r\n        # 3. Update SO status to \"Delivery Failed\"\r\n        frappe.db.set_value(\"Sales Order\", so_name, \"custom_delivery_status\", \"Delivery Failed\", update_modified=False)\r\n\r\n        # Show success summary\r\n        frappe.msgprint(\r\n            \"Delivery marked as failed. Automatic actions completed:<br><br>\"\r\n            \"✅ Advance refunded: <b>%s</b><br>\"\r\n            \"✅ Stock returned to: <b>%s</b><br>\"\r\n            \"✅ SO status updated to 'Delivery Failed'<br><br>\"\r\n            \"Sales Order %s can be used to create new DN for retry.\" % (\r\n                frappe.format_value(advance_paid, {\"fieldtype\": \"Currency\"}),\r\n                source_warehouse,\r\n                so_name\r\n            ),\r\n            indicator=\"orange\",\r\n            title=\"Delivery Failed Processed\"\r\n        )\r\n\r\n    else:\r\n        frappe.msgprint(\r\n            \"Delivery marked as failed, but linked Sales Order not found.<br>\"\r\n            \"No refund or stock return processed.\",\r\n            indicator=\"orange\",\r\n            title=\"No SO Link\"\r\n        )\r\n\r\n# ========================================\r\n# CASE 3: Auto-Close Sales Order on Return Received\r\n# Purpose: Close linked SO when return is physically received\r\n# ========================================\r\nelif doc.is_return == 1 and doc.custom_return_status == \"Return Received\":\r\n    # Get old custom_return_status to detect actual status changes\r\n    old_status = frappe.db.get_value(\r\n        \"Delivery Note\",\r\n        doc.name,\r\n        \"custom_return_status\"\r\n    )\r\n\r\n    # Only process if status just changed TO \"Return Received\"\r\n    if old_status != \"Return Received\":\r\n        # Get all unique Sales Orders linked to this DN Return\r\n        so_names = frappe.db.sql(\"\"\"\r\n            SELECT DISTINCT dni.against_sales_order\r\n            FROM `tabDelivery Note Item` dni\r\n            WHERE dni.parent = %s\r\n                AND dni.against_sales_order IS NOT NULL\r\n                AND dni.against_sales_order != ''\r\n        \"\"\", (doc.name,), as_dict=1)\r\n\r\n        if not so_names:\r\n            # No Sales Order linked - log for debugging but don't block\r\n            frappe.log_error(\r\n                \"DN Return %s has no linked Sales Order. Cannot auto-close SO.\" % doc.name,\r\n                \"Auto Close SO Warning\"\r\n            )\r\n        else:\r\n            # Process each linked Sales Order\r\n            closed_count = 0\r\n            already_closed_count = 0\r\n\r\n            for row in so_names:\r\n                so_name = row.against_sales_order\r\n\r\n                # Validate SO exists\r\n                if not frappe.db.exists(\"Sales Order\", so_name):\r\n                    frappe.log_error(\r\n                        \"Sales Order %s referenced by DN Return %s does not exist.\" % (so_name, doc.name),\r\n                        \"Auto Close SO Error\"\r\n                    )\r\n                    continue\r\n\r\n                # Check current SO status\r\n                current_so_status = frappe.db.get_value(\"Sales Order\", so_name, \"status\")\r\n\r\n                if current_so_status == \"Closed\":\r\n                    # Already closed - skip\r\n                    already_closed_count = already_closed_count + 1\r\n                    continue\r\n\r\n                # Close the Sales Order and set return fields\r\n                # Match API behavior exactly for redundancy\r\n                frappe.db.set_value(\r\n                    \"Sales Order\",\r\n                    so_name,\r\n                    {\r\n                        \"custom_is_returned\": 1,\r\n                        \"custom_return_date\": frappe.utils.nowdate(),\r\n                        \"custom_return_reference\": doc.name,\r\n                        \"status\": \"Closed\"\r\n                    },\r\n                    update_modified=False\r\n                )\r\n\r\n                # Add audit comment to SO\r\n                so_doc = frappe.get_doc(\"Sales Order\", so_name)\r\n                so_doc.add_comment(\r\n                    \"Comment\",\r\n                    \"Auto-closed due to return received: DN Return %s (custom_return_status = Return Received)\" % doc.name\r\n                )\r\n\r\n                closed_count = closed_count + 1\r\n\r\n            # Show summary message to user\r\n            if closed_count > 0:\r\n                if closed_count == 1:\r\n                    msg = \"Sales Order %s has been automatically closed.\" % so_names[0].against_sales_order\r\n                else:\r\n                    msg = \"%s Sales Orders have been automatically closed.\" % closed_count\r\n\r\n                frappe.msgprint(\r\n                    msg,\r\n                    alert=True,\r\n                    indicator=\"green\",\r\n                    title=\"Sales Orders Closed\"\r\n                )\r\n\r\n            if already_closed_count > 0:\r\n                frappe.msgprint(\r\n                    \"%s Sales Order(s) were already closed.\" % already_closed_count,\r\n                    alert=True,\r\n                    indicator=\"blue\",\r\n                    title=\"Already Closed\"\r\n                )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.717099",
  "module": "Electro Zone",
  "name": "Payment Entry - Update SO on Payment",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Payment Entry",
  "script": "# Payment Entry - Update SO on Payment\r\n# Event: After Submit\r\n# Purpose: Recalculate SO per_billed when PE allocated to Sales Invoice\r\n# ADDED: 2025-12-17 - Fix for per_billed not updating with subsequent payments\r\n\r\n# Only process Customer payments (Receive type)\r\nif doc.payment_type == \"Receive\" and doc.party_type == \"Customer\":\r\n\r\n    # Track which Sales Orders we've already updated (avoid duplicates)\r\n    updated_sales_orders = []\r\n\r\n    # Check all references in this Payment Entry\r\n    for ref in doc.references:\r\n        # Only process Sales Invoice references\r\n        if ref.reference_doctype == \"Sales Invoice\":\r\n            si_name = ref.reference_name\r\n\r\n            # Get Sales Order linked to this Sales Invoice\r\n            sales_order = frappe.db.sql(\"\"\"\r\n                SELECT DISTINCT si_item.sales_order\r\n                FROM `tabSales Invoice Item` si_item\r\n                WHERE si_item.parent = %s\r\n                AND si_item.sales_order IS NOT NULL\r\n                LIMIT 1\r\n            \"\"\", (si_name,))\r\n\r\n            if sales_order and sales_order[0][0]:\r\n                so_name = sales_order[0][0]\r\n\r\n                # Skip if we already updated this SO (PE might pay multiple SIs from same SO)\r\n                if so_name in updated_sales_orders:\r\n                    continue\r\n\r\n                # Mark as updated\r\n                updated_sales_orders.append(so_name)\r\n\r\n                # Recalculate SO billing status\r\n                try:\r\n                    # Get SO details\r\n                    so_doc = frappe.get_doc(\"Sales Order\", so_name)\r\n                    so_grand_total = so_doc.grand_total or 0\r\n\r\n                    # Query 1: Get total invoiced amount for this SO\r\n                    total_invoiced = frappe.db.sql(\"\"\"\r\n                        SELECT IFNULL(SUM(si.grand_total), 0) as total\r\n                        FROM `tabSales Invoice` si\r\n                        INNER JOIN `tabSales Invoice Item` si_item\r\n                            ON si_item.parent = si.name\r\n                        WHERE si_item.sales_order = %s\r\n                        AND si.docstatus = 1\r\n                        AND si.is_return = 0\r\n                    \"\"\", (so_name,))[0][0] or 0\r\n\r\n                    # Query 2: Get total outstanding from all invoices linked to this SO\r\n                    total_outstanding = frappe.db.sql(\"\"\"\r\n                        SELECT IFNULL(SUM(si.outstanding_amount), 0) as total\r\n                        FROM `tabSales Invoice` si\r\n                        INNER JOIN `tabSales Invoice Item` si_item\r\n                            ON si_item.parent = si.name\r\n                        WHERE si_item.sales_order = %s\r\n                        AND si.docstatus = 1\r\n                        AND si.is_return = 0\r\n                    \"\"\", (so_name,))[0][0] or 0\r\n\r\n                    # Calculate total paid from outstanding\r\n                    total_paid = total_invoiced - total_outstanding\r\n\r\n                    # Calculate percentages\r\n                    per_billed = (total_paid / so_grand_total * 100) if so_grand_total > 0 else 0\r\n\r\n                    # Determine billing_status\r\n                    if per_billed == 0:\r\n                        billing_status = \"Not Paid\"\r\n                    elif per_billed < 100:\r\n                        billing_status = \"Partly Paid\"\r\n                    else:\r\n                        billing_status = \"Fully Paid\"\r\n\r\n                    # Get delivery percentage to determine overall status\r\n                    per_delivered = so_doc.per_delivered or 0\r\n\r\n                    # Determine overall SO status\r\n                    if per_billed >= 100 and per_delivered >= 100:\r\n                        so_status = \"Completed\"\r\n                    elif per_delivered >= 100 and per_billed < 100:\r\n                        so_status = \"To Bill\"\r\n                    elif per_billed >= 100 and per_delivered < 100:\r\n                        so_status = \"To Deliver\"\r\n                    else:\r\n                        so_status = \"To Deliver and Bill\"\r\n\r\n                    # Update Sales Order\r\n                    frappe.db.set_value(\"Sales Order\", so_name, {\r\n                        \"per_billed\": per_billed,\r\n                        \"billing_status\": billing_status,\r\n                        \"status\": so_status\r\n                    }, update_modified=False)\r\n\r\n                    # Determine indicator color based on payment\r\n                    if per_billed >= 100:\r\n                        msg_indicator = \"green\"\r\n                    elif per_billed > 0:\r\n                        msg_indicator = \"orange\"\r\n                    else:\r\n                        msg_indicator = \"blue\"\r\n\r\n                    frappe.msgprint(\r\n                        \"Payment recorded. Sales Order status updated:<br>\"\r\n                        \"• SO: <b>%s</b><br>\"\r\n                        \"• Delivered: <b>%.2f%%</b><br>\"\r\n                        \"• Paid: <b>%.2f%%</b><br>\"\r\n                        \"• Payment Status: <b>%s</b><br>\"\r\n                        \"• Overall Status: <b>%s</b>\" % (\r\n                            so_name,\r\n                            per_delivered,\r\n                            per_billed,\r\n                            billing_status,\r\n                            so_status\r\n                        ),\r\n                        indicator=msg_indicator,\r\n                        title=\"SO Payment Update\"\r\n                    )\r\n\r\n                except Exception as e:\r\n                    frappe.log_error(\r\n                        \"Failed to update SO billing status for %s: %s\" % (so_name, str(e)),\r\n                        \"PE SO Update Error\"\r\n                    )\r\n                    # Don't throw error - payment was successful\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.739812",
  "module": "Electro Zone",
  "name": "Sales Invoice - Block Credit Note if DN Return Not Received",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Invoice",
  "script": "# Sales Invoice - Block Credit Note if DN Return Not Received\r\n# Purpose: Prevent manual Credit Note creation - Force DN Return workflow only\r\n# Only allow Credit Notes created via \"Receive Return\" API\r\n# Event: Before Insert\r\n# DocType: Sales Invoice\r\n\r\n# Only validate for Credit Notes (Sales Invoice Returns)\r\nif doc.is_return == 1:\r\n    # ⭐ VALIDATION 1: Block ALL manual Credit Note creation\r\n    # Only allow Credit Notes created through \"Receive Return\" API\r\n    from_api = doc.get('custom_from_receive_return_api', 0)\r\n\r\n    if from_api != 1:\r\n        # This is a manual creation attempt - BLOCK IT\r\n        frappe.throw(\r\n            \"<b>Manual Credit Note creation is not allowed.</b><br><br>\"\r\n            \"You must use the DN Return workflow:<br>\"\r\n            \"1. Open the original <b>Sales Invoice</b><br>\"\r\n            \"2. Click <b>'Create Return'</b> to generate a Delivery Note Return (Draft)<br>\"\r\n            \"3. Click <b>'Issue Return'</b> button (marks items as in transit)<br>\"\r\n            \"4. Click <b>'Receive Return'</b> button (creates Credit Note automatically)<br><br>\"\r\n            \"<b>Note:</b> Credit Notes can only be created through the authorized workflow to ensure \"\r\n            \"proper balance tracking and stock management.\",\r\n            title=\"Manual Return Not Allowed\"\r\n        )\r\n\r\n    # ⭐ VALIDATION 2: Additional check - Verify DN Return status (if DN referenced)\r\n    # Check if this is being created from a DN Return\r\n    for item in doc.items:\r\n        if item.get(\"delivery_note\"):\r\n            dn_name = item.delivery_note\r\n\r\n            # Check if the DN is a return\r\n            dn_is_return = frappe.db.get_value(\"Delivery Note\", dn_name, \"is_return\")\r\n\r\n            if dn_is_return == 1:\r\n                # Get the DN Return status\r\n                dn_return_status = frappe.db.get_value(\r\n                    \"Delivery Note\",\r\n                    dn_name,\r\n                    \"custom_return_status\"\r\n                )\r\n\r\n                # Block if status is \"Return Issued\" (items still in transit)\r\n                if dn_return_status == \"Return Issued\":\r\n                    frappe.throw(\r\n                        f\"Cannot create Credit Note for Delivery Note Return {dn_name}.<br><br>\"\r\n                        f\"<b>Current Status:</b> Return Issued (items in transit)<br>\"\r\n                        f\"<b>Required Status:</b> Return Received<br><br>\"\r\n                        f\"Please click the <b>'Receive Return'</b> button on the DN Return first to mark items as physically received.\"\r\n                    )\r\n\r\n                # Block if status is \"Draft\" (not even issued yet)\r\n                if dn_return_status == \"Draft\":\r\n                    frappe.throw(\r\n                        f\"Cannot create Credit Note for Delivery Note Return {dn_name}.<br><br>\"\r\n                        f\"<b>Current Status:</b> Draft<br>\"\r\n                        f\"<b>Required Status:</b> Return Received<br><br>\"\r\n                        f\"Please first click <b>'Issue Return'</b> and then <b>'Receive Return'</b> on the DN Return.\"\r\n                    )\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "get_customer_by_phone",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.670657",
  "module": "Electro Zone",
  "name": "API - Search Customer by Phone",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# API - Search Customer by Phone\r\n# Purpose: Search customer by phone from Address table via customer_primary_address\r\n# Endpoint: /api/method/get_customer_by_phone\r\n# Method: GET\r\n# Params: phone_number (required)\r\n# Note: Searches Address.phone (not Customer.mobile_no) via customer_primary_address\r\n\r\n# Get phone number from request\r\nphone_number = frappe.form_dict.get(\"phone_number\")\r\n\r\nif not phone_number:\r\n    frappe.response[\"message\"] = {\r\n        \"success\": False,\r\n        \"message\": \"Phone number is required\"\r\n    }\r\nelse:\r\n    # Search customer by phone in Address table (via customer_primary_address)\r\n    # This matches the Customer Phone Uniqueness validation pattern\r\n    customers = frappe.db.sql(\"\"\"\r\n        SELECT DISTINCT\r\n            c.name,\r\n            c.customer_name,\r\n            a.phone as mobile_no,\r\n            c.email_id,\r\n            c.customer_group,\r\n            c.territory,\r\n            c.custom_current_balance\r\n        FROM `tabCustomer` c\r\n        INNER JOIN `tabAddress` a ON c.customer_primary_address = a.name\r\n        WHERE a.phone LIKE %s\r\n        AND c.disabled = 0\r\n    \"\"\", (f\"%{phone_number}%\",), as_dict=1)\r\n\r\n    if not customers:\r\n        frappe.response[\"message\"] = {\r\n            \"success\": False,\r\n            \"message\": f\"No customer found with phone number: {phone_number}\"\r\n        }\r\n    else:\r\n        # Get additional details for each customer\r\n        for customer in customers:\r\n            # Get total sales\r\n            total_sales = frappe.db.sql(\"\"\"\r\n                SELECT\r\n                    COUNT(*) as total_orders,\r\n                    SUM(grand_total) as total_amount\r\n                FROM `tabSales Order`\r\n                WHERE customer = %s\r\n                AND docstatus = 1\r\n            \"\"\", (customer.name,), as_dict=1)\r\n\r\n            if total_sales and len(total_sales) > 0:\r\n                customer[\"total_orders\"] = total_sales[0].get(\"total_orders\", 0)\r\n                customer[\"total_sales_amount\"] = total_sales[0].get(\"total_amount\", 0)\r\n            else:\r\n                customer[\"total_orders\"] = 0\r\n                customer[\"total_sales_amount\"] = 0\r\n\r\n            # Get last order date\r\n            last_order = frappe.db.get_value(\"Sales Order\",\r\n                filters={\"customer\": customer.name, \"docstatus\": 1},\r\n                fieldname=\"transaction_date\",\r\n                order_by=\"transaction_date desc\"\r\n            )\r\n            customer[\"last_order_date\"] = last_order\r\n\r\n        frappe.response[\"message\"] = {\r\n            \"success\": True,\r\n            \"customers\": customers,\r\n            \"count\": len(customers)\r\n        }\r\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.713572",
  "module": "Electro Zone",
  "name": "Payment Entry - Auto-Allocate Outstanding Invoices (FIFO)",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Payment Entry",
  "script": "# Payment Entry - Auto-Allocate Outstanding Invoices (FIFO)\r\n# Event: Before Save\r\n# Purpose: Automatically allocate payment to outstanding invoices (oldest first)\r\n# UPDATED (2025-12-28): Added support for Pay type to auto-allocate to Credit Notes\r\n\r\n# Only process Customer payments (Receive or Pay type)\r\nif doc.party_type == \"Customer\" and doc.payment_type == \"Receive\":\r\n    customer = doc.party\r\n\r\n    # CRITICAL: Skip auto-created PEs from SO balance allocation\r\n    # These PEs are already linked to specific SOs and should not auto-allocate to invoices\r\n    auto_created_from_so = frappe.get_all(\r\n        \"Comment\",\r\n        filters={\r\n            \"reference_doctype\": \"Payment Entry\",\r\n            \"reference_name\": doc.name,\r\n            \"content\": \"AUTO_CREATED_FROM_SO_BALANCE_DO_NOT_UPDATE_BALANCE\"\r\n        },\r\n        limit=1\r\n    )\r\n\r\n    is_auto_created_from_so = len(auto_created_from_so) > 0\r\n\r\n    # Also check if PE already has SO reference (manual or auto-created)\r\n    has_so_reference = False\r\n    if doc.references:\r\n        for ref in doc.references:\r\n            if ref.reference_doctype == \"Sales Order\":\r\n                has_so_reference = True\r\n                break\r\n\r\n    # Only auto-allocate if this is a manual PE (not from SO)\r\n    if not is_auto_created_from_so and not has_so_reference and customer and doc.paid_amount > 0:\r\n        # Get outstanding Sales Invoices for this customer (oldest first)\r\n        outstanding_invoices = frappe.db.sql(\"\"\"\r\n            SELECT\r\n                name,\r\n                posting_date,\r\n                outstanding_amount,\r\n                grand_total\r\n            FROM `tabSales Invoice`\r\n            WHERE\r\n                customer = %s\r\n                AND docstatus = 1\r\n                AND outstanding_amount > 0\r\n            ORDER BY posting_date ASC, creation ASC\r\n        \"\"\", (customer,), as_dict=1)\r\n\r\n        if outstanding_invoices:\r\n            # Clear existing references (if any)\r\n            doc.references = []\r\n\r\n            # Available amount to allocate\r\n            remaining_amount = doc.paid_amount\r\n            allocated_count = 0\r\n\r\n            # Allocate to invoices in FIFO order\r\n            for invoice in outstanding_invoices:\r\n                if remaining_amount <= 0:\r\n                    break\r\n\r\n                outstanding = invoice.outstanding_amount\r\n\r\n                # Determine allocation amount\r\n                if remaining_amount >= outstanding:\r\n                    # Fully pay this invoice\r\n                    allocated_amount = outstanding\r\n                else:\r\n                    # Partially pay this invoice\r\n                    allocated_amount = remaining_amount\r\n\r\n                # Add to references table\r\n                doc.append(\"references\", {\r\n                    \"reference_doctype\": \"Sales Invoice\",\r\n                    \"reference_name\": invoice.name,\r\n                    \"total_amount\": invoice.grand_total,\r\n                    \"outstanding_amount\": outstanding,\r\n                    \"allocated_amount\": allocated_amount\r\n                })\r\n\r\n                # Reduce remaining amount\r\n                remaining_amount = remaining_amount - allocated_amount\r\n                allocated_count = allocated_count + 1\r\n\r\n            # Show message to user\r\n            if allocated_count > 0:\r\n                if remaining_amount > 0:\r\n                    frappe.msgprint(\r\n                        \"Payment auto-allocated to <b>%s invoice(s)</b>.<br>\"\r\n                        \"Allocated: <b>%s</b><br>\"\r\n                        \"Unallocated (Advance): <b>%s</b>\" % (\r\n                            allocated_count,\r\n                            frappe.format_value(doc.paid_amount - remaining_amount, {\"fieldtype\": \"Currency\"}),\r\n                            frappe.format_value(remaining_amount, {\"fieldtype\": \"Currency\"})\r\n                        ),\r\n                        indicator=\"blue\",\r\n                        title=\"Auto-Allocation Complete\"\r\n                    )\r\n                else:\r\n                    frappe.msgprint(\r\n                        \"Payment auto-allocated to <b>%s invoice(s)</b>.<br>\"\r\n                        \"All amount allocated.\" % allocated_count,\r\n                        indicator=\"green\",\r\n                        title=\"Auto-Allocation Complete\"\r\n                    )\r\n        else:\r\n            # No outstanding invoices - payment becomes advance\r\n            frappe.msgprint(\r\n                \"No outstanding invoices found for this customer.<br>\"\r\n                \"Payment will be recorded as advance payment.\",\r\n                indicator=\"blue\",\r\n                title=\"No Outstanding Invoices\"\r\n            )\r\n    else:\r\n        # Skip auto-allocation - this PE is from SO balance or already has SO reference\r\n        if is_auto_created_from_so:\r\n            frappe.msgprint(\r\n                \"Auto-allocation skipped: Payment Entry created from Sales Order advance.<br>\"\r\n                \"This payment is linked to a specific Sales Order.\",\r\n                indicator=\"blue\",\r\n                title=\"SO Advance Payment\"\r\n            )\r\n        elif has_so_reference:\r\n            frappe.msgprint(\r\n                \"Auto-allocation skipped: Payment Entry already linked to Sales Order.\",\r\n                indicator=\"blue\",\r\n                title=\"SO Payment\"\r\n            )\r\n\r\n# Handle Pay to Customer (Refund) - Auto-allocate to Credit Notes\r\nelif doc.party_type == \"Customer\" and doc.payment_type == \"Pay\":\r\n    customer = doc.party\r\n\r\n    if customer and doc.paid_amount > 0:\r\n        # Get outstanding Credit Notes for this customer (oldest first)\r\n        # Credit Notes are Sales Invoices with is_return=1 and NEGATIVE outstanding_amount\r\n        outstanding_credit_notes = frappe.db.sql(\"\"\"\r\n            SELECT\r\n                name,\r\n                posting_date,\r\n                outstanding_amount,\r\n                grand_total\r\n            FROM `tabSales Invoice`\r\n            WHERE\r\n                customer = %s\r\n                AND docstatus = 1\r\n                AND is_return = 1\r\n                AND outstanding_amount < 0\r\n            ORDER BY posting_date ASC, creation ASC\r\n        \"\"\", (customer,), as_dict=1)\r\n\r\n        if outstanding_credit_notes:\r\n            # Clear existing references (if any)\r\n            doc.references = []\r\n\r\n            # Available amount to allocate\r\n            remaining_amount = doc.paid_amount\r\n            allocated_count = 0\r\n\r\n            # Allocate to Credit Notes in FIFO order\r\n            for credit_note in outstanding_credit_notes:\r\n                if remaining_amount <= 0:\r\n                    break\r\n\r\n                # Credit Notes have NEGATIVE outstanding_amount (e.g., -5000)\r\n                # We need absolute value to match with positive payment amount\r\n                outstanding_abs = abs(credit_note.outstanding_amount)\r\n\r\n                # Determine allocation amount\r\n                if remaining_amount >= outstanding_abs:\r\n                    # Fully close this Credit Note\r\n                    allocated_amount = outstanding_abs\r\n                else:\r\n                    # Partially close this Credit Note\r\n                    allocated_amount = remaining_amount\r\n\r\n                # Add to references table\r\n                # CRITICAL: allocated_amount must be NEGATIVE to match Credit Note's negative outstanding\r\n                doc.append(\"references\", {\r\n                    \"reference_doctype\": \"Sales Invoice\",\r\n                    \"reference_name\": credit_note.name,\r\n                    \"total_amount\": credit_note.grand_total,\r\n                    \"outstanding_amount\": credit_note.outstanding_amount,\r\n                    \"allocated_amount\": -allocated_amount  # Negative to match Credit Note\r\n                })\r\n\r\n                # Reduce remaining amount\r\n                remaining_amount = remaining_amount - allocated_amount\r\n                allocated_count = allocated_count + 1\r\n\r\n            # Show message to user\r\n            if allocated_count > 0:\r\n                if remaining_amount > 0:\r\n                    frappe.msgprint(\r\n                        \"Refund auto-allocated to <b>%s Credit Note(s)</b>.<br>\"\r\n                        \"Allocated: <b>%s</b><br>\"\r\n                        \"Remaining: <b>%s</b> (will increase customer balance)\" % (\r\n                            allocated_count,\r\n                            frappe.format_value(doc.paid_amount - remaining_amount, {\"fieldtype\": \"Currency\"}),\r\n                            frappe.format_value(remaining_amount, {\"fieldtype\": \"Currency\"})\r\n                        ),\r\n                        indicator=\"blue\",\r\n                        title=\"Auto-Allocation Complete\"\r\n                    )\r\n                else:\r\n                    frappe.msgprint(\r\n                        \"Refund auto-allocated to <b>%s Credit Note(s)</b>.<br>\"\r\n                        \"All amount allocated to close Credit Notes.\" % allocated_count,\r\n                        indicator=\"green\",\r\n                        title=\"Auto-Allocation Complete\"\r\n                    )\r\n        else:\r\n            # No outstanding Credit Notes - show warning\r\n            frappe.msgprint(\r\n                \"No outstanding Credit Notes found for this customer.<br>\"\r\n                \"Payment will be processed as direct refund (customer balance will be updated).\",\r\n                indicator=\"orange\",\r\n                title=\"No Credit Notes to Close\"\r\n            )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Cancel",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.698042",
  "module": "Electro Zone",
  "name": "Delivery Note - Block Cancel if Delivered",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Delivery Note",
  "script": "# DN - Block Cancel if Delivered or Out for Delivery\r\n# Event: Before Cancel\r\n# Purpose: Prevent cancellation of DNs that are already delivered or out for delivery\r\n# This blocks ERPNext's automatic cascade cancel from Sales Order\r\n\r\n# Get workflow state (safely handle if field doesn't exist)\r\nworkflow_state = doc.get('workflow_state', '')\r\n\r\n# Define states that CANNOT be cancelled\r\n# These are DNs that are already in the delivery process or completed\r\nforbidden_states = ['Out for Delivery', 'Delivered']\r\n\r\n# Check if DN is in a forbidden state\r\nif workflow_state in forbidden_states:\r\n    # Calculate docstatus display\r\n    docstatus_display = \"Submitted (1)\" if doc.docstatus == 1 else \"Draft (0)\"\r\n\r\n    frappe.throw(\r\n        \"❌ <b>Cannot Cancel Delivery Note</b><br><br>\"\r\n        \"<b>Delivery Note:</b> %s<br>\"\r\n        \"<b>Current State:</b> %s<br>\"\r\n        \"<b>Doc Status:</b> %s<br><br>\"\r\n        \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br><br>\"\r\n        \"<b>⚠️ Why This Is Blocked:</b><br>\"\r\n        \"This delivery note is already <b>%s</b>. Items have been dispatched or delivered to the customer. \"\r\n        \"Cancelling this document would create incorrect audit trails and accounting records.<br><br>\"\r\n        \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br><br>\"\r\n        \"<b>✅ What To Do Instead:</b><br><br>\"\r\n        \"If items need to be returned:<br>\"\r\n        \"1. Open this Delivery Note: <b>%s</b><br>\"\r\n        \"2. Click <b>Actions</b> → <b>Return Items</b><br>\"\r\n        \"3. This will properly handle:<br>\"\r\n        \"   • Stock return to warehouse<br>\"\r\n        \"   • Customer refund/balance update<br>\"\r\n        \"   • Proper audit trail<br><br>\"\r\n        \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br><br>\"\r\n        \"<b>If You're Trying to Cancel the Sales Order:</b><br>\"\r\n        \"You cannot cancel a Sales Order when its Delivery Note is in <b>%s</b> state. \"\r\n        \"The DN must be in <b>Pending Dispatch</b> state to allow SO cancellation.<br><br>\"\r\n        \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br><br>\"\r\n        \"<b>Cancellation Is ONLY Allowed When:</b><br>\"\r\n        \"• workflow_state = <b>Pending Dispatch</b> (items not yet sent out)<br><br>\"\r\n        \"Contact your system administrator if you need assistance.\" % (\r\n            doc.name,\r\n            workflow_state,\r\n            docstatus_display,\r\n            workflow_state,\r\n            doc.name,\r\n            workflow_state\r\n        ),\r\n        title=\"🚫 Cancellation Blocked - Already Delivered\"\r\n    )\r\n\r\n# ALLOWED states for cancellation:\r\n# - \"Pending Dispatch\" (not yet sent out - safe to cancel)\r\n# - \"\" or None (no workflow state set - old DNs without workflow)\r\n# - Any DN in Draft state (docstatus=0)\r\n\r\n# Add info message for successful cancellation of Pending Dispatch DNs\r\nif workflow_state == \"Pending Dispatch\":\r\n    frappe.msgprint(\r\n        \"Cancelling Delivery Note in <b>Pending Dispatch</b> state.<br>\"\r\n        \"Stock will be returned from Hold warehouse to source warehouse.\",\r\n        indicator=\"blue\",\r\n        title=\"DN Cancellation\"\r\n    )\r\n\r\n# If we reach here, cancellation is allowed\r\n# No further action needed - let ERPNext proceed with cancellation\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save (Submitted Document)",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.757661",
  "module": "Electro Zone",
  "name": "Sales Order - Force Closed Status If Returned",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# Sales Order - Force Closed Status If Returned\r\n# Purpose: Prevent status reversion for returned orders\r\n# Event: Before Save (Submitted Document)\r\n# DocType: Sales Order\r\n# Phase: SO Return Auto-Close (SIMPLE SOLUTION)\r\n\r\n# Check if this SO is marked as returned\r\nif doc.get('custom_is_returned', 0) == 1:\r\n    # This order has been returned - force status to Closed\r\n    # This intercepts ERPNext's status recalculation BEFORE it saves\r\n    doc.status = \"Closed\"\r\n\r\n    # Log for debugging (optional)\r\n    frappe.log_error(\r\n        \"SO %s status forced to Closed (custom_is_returned=1)\" % doc.name,\r\n        \"Returned SO Status Protection\"\r\n    )\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.691268",
  "module": "Electro Zone",
  "name": "Customer Quick Create - Validate Phone Uniqueness",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Customer Quick Create",
  "script": "# Purpose: Validate that the phone number is unique across all addresses\r\n# Ensures no two customers can have the same phone number\r\n\r\n# Get phone number from form\r\nphone = doc.phone\r\n\r\n# Skip validation if no phone provided (though it's mandatory)\r\nif not phone:\r\n    frappe.throw(\"Phone number is required\")\r\n\r\n# Remove spaces and formatting for consistent comparison\r\nphone_clean = phone.replace(\" \", \"\").replace(\"-\", \"\").replace(\"(\", \"\").replace(\")\", \"\").replace(\"+\", \"\")\r\n\r\n# Check if any existing address has this phone number\r\nexisting_addresses = frappe.db.sql(\"\"\"\r\n    SELECT\r\n        addr.name,\r\n        addr.phone,\r\n        link.link_name as customer_id,\r\n        cust.customer_name\r\n    FROM `tabAddress` addr\r\n    LEFT JOIN `tabDynamic Link` link\r\n        ON link.parent = addr.name\r\n        AND link.parenttype = 'Address'\r\n        AND link.link_doctype = 'Customer'\r\n    LEFT JOIN `tabCustomer` cust\r\n        ON cust.name = link.link_name\r\n    WHERE addr.phone = %s\r\n    LIMIT 1\r\n\"\"\", (phone,), as_dict=1)\r\n\r\nif existing_addresses:\r\n    existing = existing_addresses[0]\r\n    customer_info = existing.customer_name or existing.customer_id or \"Unknown\"\r\n\r\n    frappe.throw(\r\n        \"Phone number %s already exists for customer: %s<br><br>\"\r\n        \"Each customer must have a unique phone number. Please use a different number or update the existing customer record.\" % (phone, customer_info),\r\n        title=\"Duplicate Phone Number\"\r\n    )\r\n\r\n# Additional validation: Check phone format (basic)\r\nif len(phone_clean) < 10:\r\n    frappe.throw(\r\n        \"Phone number %s appears to be invalid. Phone numbers must have at least 10 digits.\" % phone,\r\n        title=\"Invalid Phone Number\"\r\n    )\r\n\r\n# Success - validation passed\r\nfrappe.msgprint(\"Phone number %s validated successfully\" % phone, alert=True)\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.689619",
  "module": "Electro Zone",
  "name": "Customer Quick Create - Auto Create Records",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Customer Quick Create",
  "script": "# Purpose: Automatically create Customer and Address records after Customer Quick Create is submitted\r\n# This script creates an address first, then creates customer with address reference\r\n\r\n# Validate that we haven't already created records\r\nif doc.created_customer or doc.created_address:\r\n    frappe.throw(\"Records have already been created for this form\")\r\n\r\n# Step 1: Create Address first (without customer link initially)\r\naddress = frappe.new_doc(\"Address\")\r\naddress.address_title = doc.address_title\r\naddress.address_type = doc.address_type\r\naddress.address_line1 = doc.address_line1 or \"\"\r\naddress.address_line2 = doc.address_line2 or \"\"\r\naddress.city = doc.city\r\naddress.state = doc.state or \"\"\r\naddress.country = doc.country\r\naddress.pincode = doc.postal_code or \"\"\r\naddress.phone = doc.phone\r\n\r\n# Set as primary and billing address\r\naddress.is_primary_address = 1\r\naddress.is_shipping_address = 0\r\n\r\ntry:\r\n    address.insert(ignore_permissions=True)\r\n    frappe.msgprint(\"Address %s created successfully\" % address.name)\r\nexcept Exception as e:\r\n    frappe.log_error(\"Address creation failed\", str(e))\r\n    frappe.throw(\"Failed to create address. Check Error Log for details.\")\r\n\r\n# Step 2: Create Customer with address reference\r\ncustomer = frappe.new_doc(\"Customer\")\r\ncustomer.customer_name = doc.customer_name\r\ncustomer.customer_type = \"Individual\"\r\ncustomer.customer_group = doc.customer_group\r\ncustomer.territory = doc.territory\r\n\r\n# Set the primary address on customer during creation\r\ncustomer.customer_primary_address = address.name\r\n\r\ntry:\r\n    customer.insert(ignore_permissions=True)\r\n    frappe.msgprint(\"Customer %s created successfully\" % customer.name)\r\nexcept Exception as e:\r\n    frappe.log_error(\"Customer creation failed\", str(e))\r\n    frappe.throw(\"Failed to create customer. Check Error Log for details.\")\r\n\r\n# Step 3: Link address to customer using Dynamic Link\r\naddress.append(\"links\", {\r\n    \"link_doctype\": \"Customer\",\r\n    \"link_name\": customer.name\r\n})\r\n\r\ntry:\r\n    address.save(ignore_permissions=True)\r\n    frappe.msgprint(\"Address linked to customer successfully\")\r\nexcept Exception as e:\r\n    frappe.log_error(\"Address link failed\", str(e))\r\n    frappe.throw(\"Failed to link address to customer. Check Error Log for details.\")\r\n\r\n# Step 4: Update Customer Quick Create with created record links\r\nfrappe.db.set_value(\"Customer Quick Create\", doc.name, {\r\n    \"created_customer\": customer.name,\r\n    \"created_address\": address.name\r\n})\r\n\r\n# Step 5: Reload customer to get updated address display\r\n# ERPNext automatically populates primary_address field when customer_primary_address is set\r\ncustomer.reload()\r\n\r\nfrappe.msgprint(\"Customer and address created successfully! Customer: %s, Address: %s\" % (customer.name, address.name), alert=True)\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.734612",
  "module": "Electro Zone",
  "name": "Sales Invoice - Auto-Allocate Balance",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Invoice",
  "script": "# Sales Invoice - Auto-Allocate Balance (Real Payment)\r\n# Event: After Submit\r\n# Purpose: Create Payment Entry to allocate balance to invoice (ERPNext accounting integration)\r\n\r\nif not doc.is_return and doc.customer and doc.outstanding_amount > 0:\r\n    customer = doc.customer\r\n\r\n    # Check if this invoice is from a Sales Order\r\n    sales_order = None\r\n    for item in doc.items:\r\n        if item.get(\"sales_order\"):\r\n            sales_order = item.sales_order\r\n            break\r\n\r\n    # Only auto-allocate if invoice is from SO (balance was deducted at SO stage)\r\n    if sales_order:\r\n        # Get SO advance_paid amount\r\n        so_advance = frappe.db.get_value(\"Sales Order\", sales_order, \"advance_paid\") or 0\r\n\r\n        if so_advance > 0 and doc.outstanding_amount > 0:\r\n            # Create PE to represent balance → invoice allocation\r\n            # This PE has references table properly set, creating real accounting entries\r\n\r\n            allocate_amount = min(so_advance, doc.outstanding_amount)\r\n\r\n            # Create Payment Entry\r\n            pe = frappe.new_doc(\"Payment Entry\")\r\n            pe.payment_type = \"Receive\"\r\n            pe.party_type = \"Customer\"\r\n            pe.party = customer\r\n            pe.posting_date = doc.posting_date\r\n            pe.company = doc.company\r\n\r\n            # Set accounts\r\n            pe.paid_from = frappe.db.get_value(\r\n                \"Company\",\r\n                doc.company,\r\n                \"default_receivable_account\"\r\n            )\r\n\r\n            pe.paid_to = frappe.db.get_value(\r\n                \"Company\",\r\n                doc.company,\r\n                \"default_cash_account\"\r\n            ) or frappe.db.get_value(\r\n                \"Company\",\r\n                doc.company,\r\n                \"default_bank_account\"\r\n            )\r\n\r\n            pe.paid_amount = allocate_amount\r\n            pe.received_amount = allocate_amount\r\n\r\n            # CRITICAL: Add invoice to references (creates real payment allocation)\r\n            pe.append(\"references\", {\r\n                \"reference_doctype\": \"Sales Invoice\",\r\n                \"reference_name\": doc.name,\r\n                \"total_amount\": doc.grand_total,\r\n                \"outstanding_amount\": doc.outstanding_amount,\r\n                \"allocated_amount\": allocate_amount\r\n            })\r\n\r\n            # Add flag to skip balance update (balance already updated at SO stage)\r\n            pe.add_comment(\r\n                \"Comment\",\r\n                \"SKIP_BALANCE_UPDATE_AUTO_CREATED_FROM_SO_ADVANCE\"\r\n            )\r\n\r\n            try:\r\n                pe.insert(ignore_permissions=True)\r\n                pe.submit()\r\n\r\n                frappe.msgprint(\r\n                    \"Payment Entry <b>%s</b> auto-created from Sales Order advance.<br>\"\r\n                    \"Amount: <b>%s</b><br>\"\r\n                    \"This creates proper accounting entries in ERPNext.\" % (\r\n                        pe.name,\r\n                        frappe.format_value(allocate_amount, {\"fieldtype\": \"Currency\"})\r\n                    ),\r\n                    indicator=\"green\",\r\n                    title=\"Payment Allocated\"\r\n                )\r\n\r\n            except Exception as e:\r\n                frappe.log_error(\r\n                    \"Failed to create Payment Entry for SI %s: %s\" % (doc.name, str(e)),\r\n                    \"Balance Allocation Error\"\r\n                )\r\n                frappe.msgprint(\r\n                    \"Failed to auto-allocate balance: %s\" % str(e),\r\n                    indicator=\"orange\",\r\n                    title=\"Auto-Allocation Failed\"\r\n                )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Cancel",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.744791",
  "module": "Electro Zone",
  "name": "Sales Order - Cancel and Return Stock",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# Sales Order - Cancel and Return Stock\r\n# Event: After Cancel\r\n# Purpose: Cancel Pending Dispatch DNs and return stock to source warehouse\r\n# MODIFIED (2025-12-29): Removed balance restoration logic\r\n\r\n# ============================================================\r\n# AUTO-CANCEL DRAFT DELIVERY NOTES LINKED TO THIS SO\r\n# ============================================================\r\n# Only cancels DNs in \"Pending Dispatch\" state (not submitted)\r\n# Submitted DNs are blocked in Before Cancel validation\r\n# DNs remain in system for audit trail but are marked as cancelled\r\n\r\ndn_items = frappe.db.get_all(\r\n    \"Delivery Note Item\",\r\n    filters={\"against_sales_order\": doc.name},\r\n    fields=[\"parent\"],\r\n    distinct=True\r\n)\r\n\r\nif dn_items:\r\n    dn_names = list(set([item.parent for item in dn_items]))  # Unique DN names\r\n\r\n    for dn_name in dn_names:\r\n        try:\r\n            dn_doc = frappe.get_doc(\"Delivery Note\", dn_name)\r\n            dn_workflow_state = dn_doc.get(\"workflow_state\", \"\")\r\n\r\n            # ONLY cancel DNs that are in \"Pending Dispatch\" state\r\n            # This matches the Before Cancel validation\r\n            if dn_workflow_state == \"Pending Dispatch\":\r\n                # Set to cancelled status (docstatus=2) and update workflow_state\r\n                # This keeps the DN in system but marks it as cancelled\r\n                frappe.db.set_value(\r\n                    \"Delivery Note\",\r\n                    dn_name,\r\n                    {\r\n                        \"docstatus\": 2,\r\n                        \"workflow_state\": \"Cancelled\"\r\n                    },\r\n                    update_modified=False\r\n                )\r\n\r\n                # Add comment for audit trail\r\n                dn_doc.add_comment(\r\n                    \"Comment\",\r\n                    \"Auto-cancelled because linked Sales Order %s was cancelled\" % doc.name\r\n                )\r\n\r\n                frappe.msgprint(\r\n                    \"Cancelled Delivery Note: <b>%s</b> (was in Pending Dispatch status)\" % dn_name,\r\n                    indicator=\"blue\",\r\n                    title=\"DN Cancelled\"\r\n                )\r\n\r\n                # Log cancellation for audit trail\r\n                frappe.log_error(\r\n                    \"Cancelled DN %s (Pending Dispatch) linked to cancelled SO %s\" % (dn_name, doc.name),\r\n                    \"Auto-Cancel DN - Pending Dispatch\"\r\n                )\r\n            else:\r\n                # This shouldn't happen if Before Cancel is working correctly\r\n                frappe.msgprint(\r\n                    \"Skipped DN <b>%s</b> - not in Pending Dispatch (workflow_state: %s)\" % (dn_name, dn_workflow_state or \"(empty)\"),\r\n                    indicator=\"orange\",\r\n                    title=\"DN Not Cancelled\"\r\n                )\r\n\r\n        except Exception as e:\r\n            frappe.log_error(\r\n                \"Failed to cancel DN %s for SO %s: %s\" % (dn_name, doc.name, str(e)),\r\n                \"DN Cancellation Error\"\r\n            )\r\n            frappe.msgprint(\r\n                \"Failed to cancel Delivery Note <b>%s</b>: %s\" % (dn_name, str(e)),\r\n                indicator=\"orange\",\r\n                title=\"DN Cancellation Failed\"\r\n            )\r\n\r\n# ========== STOCK RETURN LOGIC (IMPROVED FROM PHASE 5) ==========\r\n\r\n# Find Hold warehouse\r\nhold_warehouse = frappe.db.get_value(\r\n    \"Warehouse\",\r\n    {\r\n        \"warehouse_name\": [\"like\", \"%Hold%\"],\r\n        \"company\": doc.company,\r\n        \"is_group\": 0\r\n    },\r\n    \"name\"\r\n)\r\n\r\nif not hold_warehouse:\r\n    frappe.msgprint(\r\n        \"Hold warehouse not found. Stock return skipped.\",\r\n        indicator=\"yellow\",\r\n        title=\"No Hold Warehouse\"\r\n    )\r\nelse:\r\n    # Get target warehouse from custom_source_warehouse field\r\n    target_warehouse = doc.get('custom_source_warehouse')\r\n\r\n    if not target_warehouse:\r\n        # No custom_source_warehouse set - cannot return stock\r\n        # This should not happen if SO was properly submitted\r\n        frappe.msgprint(\r\n            \"custom_source_warehouse not set. Cannot determine where to return stock. \"\r\n            \"Please manually create Stock Entry to return stock from Hold warehouse.\",\r\n            indicator=\"orange\",\r\n            title=\"Manual Stock Return Required\"\r\n        )\r\n    else:\r\n        # custom_source_warehouse is set - create NEW Stock Entry to return stock\r\n        stock_entry = frappe.new_doc(\"Stock Entry\")\r\n        stock_entry.stock_entry_type = \"Material Transfer\"\r\n        stock_entry.company = doc.company\r\n        stock_entry.posting_date = frappe.utils.nowdate()\r\n        stock_entry.posting_time = frappe.utils.nowtime()\r\n        stock_entry.set_posting_time = 1\r\n\r\n        items_added = False\r\n\r\n        for so_item in doc.items:\r\n            if not so_item.item_code or frappe.utils.flt(so_item.qty) <= 0:\r\n                continue\r\n\r\n            # Check stock availability in Hold warehouse\r\n            available_qty = frappe.utils.flt(\r\n                frappe.db.get_value(\r\n                    \"Bin\",\r\n                    {\"item_code\": so_item.item_code, \"warehouse\": hold_warehouse},\r\n                    \"actual_qty\"\r\n                ) or 0\r\n            )\r\n\r\n            if available_qty < frappe.utils.flt(so_item.qty):\r\n                frappe.msgprint(\r\n                    \"Insufficient stock in Hold for <b>%s</b>. Available: %s, Required: %s. Item skipped.\" % (\r\n                        so_item.item_code,\r\n                        available_qty,\r\n                        so_item.qty\r\n                    ),\r\n                    indicator=\"orange\",\r\n                    title=\"Insufficient Stock\"\r\n                )\r\n                continue\r\n\r\n            stock_uom = frappe.db.get_value(\"Item\", so_item.item_code, \"stock_uom\")\r\n\r\n            stock_entry.append(\"items\", {\r\n                \"item_code\": so_item.item_code,\r\n                \"qty\": frappe.utils.flt(so_item.qty),\r\n                \"s_warehouse\": hold_warehouse,\r\n                \"t_warehouse\": target_warehouse,\r\n                \"uom\": so_item.uom or stock_uom,\r\n                \"stock_uom\": stock_uom,\r\n                \"conversion_factor\": frappe.utils.flt(so_item.conversion_factor) or 1.0,\r\n                \"transfer_qty\": frappe.utils.flt(so_item.qty) * (frappe.utils.flt(so_item.conversion_factor) or 1.0)\r\n            })\r\n            items_added = True\r\n\r\n        if items_added:\r\n            try:\r\n                stock_entry.insert(ignore_permissions=True)\r\n                stock_entry.submit()\r\n\r\n                doc.add_comment(\r\n                    \"Comment\",\r\n                    \"Stock returned to %s via Stock Entry <a href=\\\"/app/stock-entry/%s\\\">%s</a>\" % (\r\n                        target_warehouse,\r\n                        stock_entry.name,\r\n                        stock_entry.name\r\n                    )\r\n                )\r\n\r\n                frappe.msgprint(\r\n                    \"Stock Entry <b>%s</b> created. Stock returned from Hold to <b>%s</b>.\" % (\r\n                        stock_entry.name,\r\n                        target_warehouse\r\n                    ),\r\n                    indicator=\"green\",\r\n                    title=\"Stock Returned\",\r\n                    alert=True\r\n                )\r\n\r\n            except Exception as e:\r\n                error_msg = str(e)\r\n                frappe.log_error(\r\n                    \"Failed to create Stock Entry for SO %s: %s\" % (doc.name, error_msg),\r\n                    \"Stock Return Error\"\r\n                )\r\n                frappe.msgprint(\r\n                    \"Failed to return stock from Hold to <b>%s</b>:<br>\"\r\n                    \"<b>Error:</b> %s<br><br>\"\r\n                    \"Please manually create Stock Entry to return stock.\" % (target_warehouse, error_msg),\r\n                    indicator=\"red\",\r\n                    title=\"Stock Return Failed\"\r\n                )\r\n        else:\r\n            frappe.msgprint(\r\n                \"No items to return from Hold warehouse (insufficient stock or no items).\",\r\n                indicator=\"yellow\",\r\n                title=\"No Items to Return\"\r\n            )\r\n\r\n# ============================================\r\n# BALANCE RESTORATION LOGIC\r\n# ============================================\r\n# Restore balance when SO is cancelled (reverse the deduction from Submit)\r\n\r\n# Get SO details\r\nso_total = doc.grand_total\r\ncustomer = doc.customer\r\n\r\n# Get current balance\r\ncurrent_balance = frappe.db.get_value(\"Customer\", customer, \"custom_current_balance\") or 0.0\r\n\r\n# Restore balance (reverse deduction - explicit assignment, no augmented operators)\r\nnew_balance = current_balance + so_total\r\n\r\n# Update balance\r\nfrappe.db.set_value(\"Customer\", customer, \"custom_current_balance\", new_balance, update_modified=False)\r\n\r\n# Create REVERSAL ledger entry\r\nledger = frappe.new_doc(\"Customer Balance Ledger\")\r\nledger.transaction_date = frappe.utils.today()\r\nledger.posting_time = frappe.utils.nowtime()\r\nledger.customer = customer\r\nledger.customer_name = doc.customer_name\r\nledger.reference_doctype = \"Sales Order\"\r\nledger.reference_document = doc.name\r\nledger.reference_date = doc.transaction_date\r\nledger.debit_amount = 0.0\r\nledger.credit_amount = so_total  # Restore customer credit\r\nledger.balance_before = current_balance\r\nledger.running_balance = new_balance\r\nledger.remarks = \"REVERSAL: Sales Order %s cancelled - Balance restored\" % doc.name\r\nledger.company = doc.company\r\nledger.created_by = frappe.session.user\r\nledger.insert(ignore_permissions=True)\r\n\r\n# Show balance restoration notification\r\nfrappe.msgprint(\r\n    \"Sales Order cancelled successfully.<br><br>\"\r\n    \"<b>Balance Restored:</b><br>\"\r\n    \"• Previous balance: <b>%s</b><br>\"\r\n    \"• Order amount: <b>%s</b><br>\"\r\n    \"• New balance: <b>%s</b><br><br>\"\r\n    \"Customer balance has been restored.\" % (\r\n        frappe.format_value(current_balance, {\"fieldtype\": \"Currency\"}),\r\n        frappe.format_value(so_total, {\"fieldtype\": \"Currency\"}),\r\n        frappe.format_value(new_balance, {\"fieldtype\": \"Currency\"})\r\n    ),\r\n    indicator=\"green\",\r\n    title=\"Balance Restored\"\r\n)",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.741666",
  "module": "Electro Zone",
  "name": "Sales Invoice - Update SO Billing Status Only",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Invoice",
  "script": "# Sales Invoice - Update SO Billing Status Only\r\n# Event: After Submit\r\n# Purpose: Update SO billing status + Credit Note balance (REFERENCE-ONLY SYSTEM)\r\n# MODIFIED (2025-12-29): Removed balance updates for regular invoices\r\n\r\nif not doc.customer:\r\n    pass\r\nelse:\r\n    customer = doc.customer\r\n    grand_total = doc.grand_total or 0.0\r\n\r\n    if not doc.is_return:\r\n        # ==================================\r\n        # REGULAR INVOICE - UPDATE SO STATUS ONLY\r\n        # ==================================\r\n\r\n        # Check if linked to Sales Order\r\n        sales_order = None\r\n        for item in doc.items:\r\n            if item.get(\"sales_order\"):\r\n                sales_order = item.sales_order\r\n                break\r\n\r\n        if sales_order:\r\n            # ============================================\r\n            # CASE 1: Invoice from Sales Order\r\n            # ============================================\r\n            # NO balance update - balance is reference-only\r\n            # Just update SO billing status based on payments\r\n\r\n            # ============================================\r\n            # UPDATE SALES ORDER BILLING STATUS\r\n            # ============================================\r\n\r\n            try:\r\n                # Get SO details\r\n                so_doc = frappe.get_doc(\"Sales Order\", sales_order)\r\n                so_grand_total = so_doc.grand_total or 0\r\n\r\n                # Query 1: Get total invoiced amount for this SO\r\n                total_invoiced = frappe.db.sql(\"\"\"\r\n                    SELECT IFNULL(SUM(si.grand_total), 0) as total\r\n                    FROM `tabSales Invoice` si\r\n                    INNER JOIN `tabSales Invoice Item` si_item\r\n                        ON si_item.parent = si.name\r\n                    WHERE si_item.sales_order = %s\r\n                    AND si.docstatus = 1\r\n                    AND si.is_return = 0\r\n                \"\"\", (sales_order,))[0][0] or 0\r\n\r\n                # Query 2: Get total outstanding from all invoices linked to this SO\r\n                total_outstanding = frappe.db.sql(\"\"\"\r\n                    SELECT IFNULL(SUM(si.outstanding_amount), 0) as total\r\n                    FROM `tabSales Invoice` si\r\n                    INNER JOIN `tabSales Invoice Item` si_item\r\n                        ON si_item.parent = si.name\r\n                    WHERE si_item.sales_order = %s\r\n                    AND si.docstatus = 1\r\n                    AND si.is_return = 0\r\n                \"\"\", (sales_order,))[0][0] or 0\r\n\r\n                # Query 3: Get total Credit Note amount (returns reduce paid amount)\r\n                total_credit_notes = frappe.db.sql(\"\"\"\r\n                    SELECT IFNULL(SUM(ABS(si.grand_total)), 0) as total\r\n                    FROM `tabSales Invoice` si\r\n                    WHERE si.return_against IN (\r\n                        SELECT parent FROM `tabSales Invoice Item`\r\n                        WHERE sales_order = %s\r\n                    )\r\n                    AND si.docstatus = 1\r\n                    AND si.is_return = 1\r\n                \"\"\", (sales_order,))[0][0] or 0\r\n\r\n                # Calculate total paid from outstanding (accounting for credit notes)\r\n                total_paid = total_invoiced - total_outstanding - total_credit_notes\r\n\r\n                # Calculate percentages\r\n                per_billed = (total_paid / so_grand_total * 100) if so_grand_total > 0 else 0\r\n\r\n                # Determine billing_status\r\n                if per_billed == 0:\r\n                    billing_status = \"Not Paid\"\r\n                elif per_billed < 100:\r\n                    billing_status = \"Partly Paid\"\r\n                else:\r\n                    billing_status = \"Fully Paid\"\r\n\r\n                # Get delivery percentage to determine overall status\r\n                per_delivered = so_doc.per_delivered or 0\r\n\r\n                # Determine overall SO status\r\n                if per_billed >= 100 and per_delivered >= 100:\r\n                    so_status = \"Completed\"\r\n                elif per_delivered >= 100 and per_billed < 100:\r\n                    so_status = \"To Bill\"\r\n                elif per_billed >= 100 and per_delivered < 100:\r\n                    so_status = \"To Deliver\"\r\n                else:\r\n                    so_status = \"To Deliver and Bill\"\r\n\r\n                # Update Sales Order\r\n                frappe.db.set_value(\"Sales Order\", sales_order, {\r\n                    \"per_billed\": per_billed,\r\n                    \"billing_status\": billing_status,\r\n                    \"status\": so_status\r\n                }, update_modified=False)\r\n\r\n                # Determine indicator color based on payment\r\n                if per_billed >= 100:\r\n                    msg_indicator = \"green\"\r\n                elif per_billed > 0:\r\n                    msg_indicator = \"orange\"\r\n                else:\r\n                    msg_indicator = \"blue\"\r\n\r\n                frappe.msgprint(\r\n                    \"Sales Order status updated:<br>\"\r\n                    \"• Delivered: <b>%.2f%%</b><br>\"\r\n                    \"• Paid: <b>%.2f%%</b><br>\"\r\n                    \"• Payment Status: <b>%s</b><br>\"\r\n                    \"• Overall Status: <b>%s</b>\" % (\r\n                        per_delivered,\r\n                        per_billed,\r\n                        billing_status,\r\n                        so_status\r\n                    ),\r\n                    indicator=msg_indicator,\r\n                    title=\"SO Updated\"\r\n                )\r\n\r\n            except Exception as e:\r\n                frappe.log_error(\r\n                    \"Failed to update SO billing status for %s: %s\" % (sales_order, str(e)),\r\n                    \"SO Billing Status Update Error\"\r\n                )\r\n                # Don't throw error - SI is already created successfully\r\n                frappe.msgprint(\r\n                    \"Warning: SO billing status update failed. Invoice created successfully.\",\r\n                    indicator=\"orange\"\r\n                )\r\n\r\n        # ============================================\r\n        # CREATE REFERENCE LEDGER ENTRY (NO BALANCE CHANGE)\r\n        # ============================================\r\n        # Track SI in ledger for audit trail\r\n        # Balance already changed by SO (avoid double-counting)\r\n        # This applies to BOTH SO-linked and direct invoices\r\n\r\n        # Get current balance (unchanged)\r\n        current_balance = frappe.db.get_value(\"Customer\", customer, \"custom_current_balance\") or 0.0\r\n\r\n        # Create REFERENCE-ONLY ledger entry\r\n        ledger = frappe.new_doc(\"Customer Balance Ledger\")\r\n        ledger.transaction_date = doc.posting_date\r\n        ledger.posting_time = doc.posting_time or frappe.utils.nowtime()\r\n        ledger.customer = customer\r\n        ledger.customer_name = doc.customer_name\r\n        ledger.reference_doctype = \"Sales Invoice\"\r\n        ledger.reference_document = doc.name\r\n        ledger.reference_date = doc.posting_date\r\n        ledger.debit_amount = 0.0  # NO change - reference only\r\n        ledger.credit_amount = 0.0  # NO change - reference only\r\n        ledger.balance_before = current_balance\r\n        ledger.running_balance = current_balance  # UNCHANGED\r\n        ledger.remarks = \"Sales Invoice %s - Reference only (Balance changed by SO: %s)\" % (\r\n            doc.name,\r\n            sales_order if sales_order else \"Direct Invoice\"\r\n        )\r\n        ledger.company = doc.company\r\n        ledger.created_by = frappe.session.user\r\n        ledger.insert(ignore_permissions=True)\r\n\r\n    else:\r\n            # ==================================\r\n            # CREDIT NOTE (Sales Return)\r\n            # ==================================\r\n            # Increase balance by credit amount\r\n\r\n            credit_amount = abs(grand_total)\r\n            current_balance = frappe.db.get_value(\"Customer\", customer, \"custom_current_balance\") or 0.0\r\n            new_balance = current_balance + credit_amount\r\n\r\n            # Update balance\r\n            frappe.db.set_value(\"Customer\", customer, \"custom_current_balance\", new_balance, update_modified=False)\r\n\r\n            # Create ledger entry\r\n            ledger = frappe.new_doc(\"Customer Balance Ledger\")\r\n            ledger.transaction_date = doc.posting_date\r\n            ledger.posting_time = doc.posting_time or frappe.utils.nowtime()\r\n            ledger.customer = customer\r\n            ledger.customer_name = doc.customer_name\r\n            ledger.reference_doctype = \"Sales Invoice\"\r\n            ledger.reference_document = doc.name\r\n            ledger.reference_date = doc.posting_date\r\n            ledger.debit_amount = 0.0\r\n            ledger.credit_amount = credit_amount\r\n            ledger.balance_before = current_balance\r\n            ledger.running_balance = new_balance\r\n            ledger.remarks = \"Credit Note %s - Sales Return (Against: %s)\" % (\r\n                doc.name,\r\n                doc.return_against or \"N/A\"\r\n            )\r\n            ledger.company = doc.company\r\n            ledger.created_by = frappe.session.user\r\n            ledger.insert(ignore_permissions=True)\r\n\r\n            # ============================================\r\n            # UPDATE SALES ORDER BILLING STATUS (RETURN)\r\n            # ============================================\r\n            # CRITICAL FIX: Recalculate per_billed after Credit Note submission\r\n            # Credit Notes reduce the paid amount, so per_billed must decrease\r\n\r\n            # Find linked Sales Order from original invoice\r\n            sales_order = None\r\n            if doc.return_against:\r\n                # Get SO from original invoice items\r\n                original_si_items = frappe.db.sql(\"\"\"\r\n                    SELECT sales_order\r\n                    FROM `tabSales Invoice Item`\r\n                    WHERE parent = %s\r\n                    AND sales_order IS NOT NULL\r\n                    LIMIT 1\r\n                \"\"\", (doc.return_against,))\r\n\r\n                if original_si_items and original_si_items[0][0]:\r\n                    sales_order = original_si_items[0][0]\r\n\r\n            if sales_order:\r\n                # Recalculate SO billing status (same logic as regular invoice)\r\n                try:\r\n                    # Get SO details\r\n                    so_doc = frappe.get_doc(\"Sales Order\", sales_order)\r\n                    so_grand_total = so_doc.grand_total or 0\r\n\r\n                    # Query 1: Get total invoiced amount for this SO (EXCLUDE returns)\r\n                    total_invoiced = frappe.db.sql(\"\"\"\r\n                        SELECT IFNULL(SUM(si.grand_total), 0) as total\r\n                        FROM `tabSales Invoice` si\r\n                        INNER JOIN `tabSales Invoice Item` si_item\r\n                            ON si_item.parent = si.name\r\n                        WHERE si_item.sales_order = %s\r\n                        AND si.docstatus = 1\r\n                        AND si.is_return = 0\r\n                    \"\"\", (sales_order,))[0][0] or 0\r\n\r\n                    # Query 2: Get total outstanding from invoices (EXCLUDE returns)\r\n                    total_outstanding = frappe.db.sql(\"\"\"\r\n                        SELECT IFNULL(SUM(si.outstanding_amount), 0) as total\r\n                        FROM `tabSales Invoice` si\r\n                        INNER JOIN `tabSales Invoice Item` si_item\r\n                            ON si_item.parent = si.name\r\n                        WHERE si_item.sales_order = %s\r\n                        AND si.docstatus = 1\r\n                        AND si.is_return = 0\r\n                    \"\"\", (sales_order,))[0][0] or 0\r\n\r\n                    # Query 3: Get total Credit Note amount (returns reduce paid amount)\r\n                    total_credit_notes = frappe.db.sql(\"\"\"\r\n                        SELECT IFNULL(SUM(ABS(si.grand_total)), 0) as total\r\n                        FROM `tabSales Invoice` si\r\n                        WHERE si.return_against IN (\r\n                            SELECT parent FROM `tabSales Invoice Item`\r\n                            WHERE sales_order = %s\r\n                        )\r\n                        AND si.docstatus = 1\r\n                        AND si.is_return = 1\r\n                    \"\"\", (sales_order,))[0][0] or 0\r\n\r\n                    # Calculate total paid (accounting for credit notes)\r\n                    total_paid = total_invoiced - total_outstanding - total_credit_notes\r\n\r\n                    # Calculate percentages\r\n                    per_billed = (total_paid / so_grand_total * 100) if so_grand_total > 0 else 0\r\n\r\n                    # Determine billing_status\r\n                    if per_billed == 0:\r\n                        billing_status = \"Not Paid\"\r\n                    elif per_billed < 100:\r\n                        billing_status = \"Partly Paid\"\r\n                    else:\r\n                        billing_status = \"Fully Paid\"\r\n\r\n                    # Get delivery percentage\r\n                    per_delivered = so_doc.per_delivered or 0\r\n\r\n                    # Determine overall SO status\r\n                    if per_billed >= 100 and per_delivered >= 100:\r\n                        so_status = \"Completed\"\r\n                    elif per_delivered >= 100 and per_billed < 100:\r\n                        so_status = \"To Bill\"\r\n                    elif per_billed >= 100 and per_delivered < 100:\r\n                        so_status = \"To Deliver\"\r\n                    else:\r\n                        so_status = \"To Deliver and Bill\"\r\n\r\n                    # Update Sales Order\r\n                    frappe.db.set_value(\"Sales Order\", sales_order, {\r\n                        \"per_billed\": per_billed,\r\n                        \"billing_status\": billing_status,\r\n                        \"status\": so_status\r\n                    }, update_modified=False)\r\n\r\n                    frappe.msgprint(\r\n                        \"Credit Note processed. Customer balance increased by <b>%s</b>.<br><br>\"\r\n                        \"• Credit amount: <b>%s</b><br>\"\r\n                        \"• New balance: <b>%s</b><br><br>\"\r\n                        \"Sales Order <b>%s</b> updated:<br>\"\r\n                        \"• Paid: <b>%.2f%%</b> (reduced by credit note)<br>\"\r\n                        \"• Payment Status: <b>%s</b><br>\"\r\n                        \"• Overall Status: <b>%s</b>\" % (\r\n                            frappe.format_value(credit_amount, {\"fieldtype\": \"Currency\"}),\r\n                            frappe.format_value(credit_amount, {\"fieldtype\": \"Currency\"}),\r\n                            frappe.format_value(new_balance, {\"fieldtype\": \"Currency\"}),\r\n                            sales_order,\r\n                            per_billed,\r\n                            billing_status,\r\n                            so_status\r\n                        ),\r\n                        indicator=\"green\",\r\n                        title=\"Credit Applied\"\r\n                    )\r\n\r\n                except Exception as e:\r\n                    frappe.log_error(\r\n                        \"Failed to update SO billing status for %s after Credit Note: %s\" % (sales_order, str(e)),\r\n                        \"SO Billing Status Update Error (Credit Note)\"\r\n                    )\r\n                    # Don't throw error - Credit Note is already created successfully\r\n                    frappe.msgprint(\r\n                        \"Credit Note processed. Customer balance increased by <b>%s</b>.<br><br>\"\r\n                        \"• Credit amount: <b>%s</b><br>\"\r\n                        \"• New balance: <b>%s</b><br><br>\"\r\n                        \"Customer can use this credit for future orders or request refund.<br><br>\"\r\n                        \"<b>Warning:</b> SO billing status update failed.\" % (\r\n                            frappe.format_value(credit_amount, {\"fieldtype\": \"Currency\"}),\r\n                            frappe.format_value(credit_amount, {\"fieldtype\": \"Currency\"}),\r\n                            frappe.format_value(new_balance, {\"fieldtype\": \"Currency\"})\r\n                        ),\r\n                        indicator=\"orange\",\r\n                        title=\"Credit Applied (Warning)\"\r\n                    )\r\n\r\n            else:\r\n                # No SO linked - just show balance update message\r\n                frappe.msgprint(\r\n                    \"Credit Note processed. Customer balance increased by <b>%s</b>.<br><br>\"\r\n                    \"• Credit amount: <b>%s</b><br>\"\r\n                    \"• New balance: <b>%s</b><br><br>\"\r\n                    \"Customer can use this credit for future orders or request refund.\" % (\r\n                        frappe.format_value(credit_amount, {\"fieldtype\": \"Currency\"}),\r\n                        frappe.format_value(credit_amount, {\"fieldtype\": \"Currency\"}),\r\n                        frappe.format_value(new_balance, {\"fieldtype\": \"Currency\"})\r\n                    ),\r\n                    indicator=\"green\",\r\n                    title=\"Credit Applied\"\r\n                )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.736620",
  "module": "Electro Zone",
  "name": "Sales Invoice - Auto-Allocate Unallocated Payment Entries",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Invoice",
  "script": "# Sales Invoice - Auto-Allocate Unallocated Payment Entries\r\n# Event: Before Submit\r\n# Purpose: Auto-pull unallocated Payment Entries to reduce invoice outstanding\r\n# Date: 2025-12-29\r\n# CRITICAL: Gets unallocated_amount from PE document (calculated field)\r\n\r\nif not doc.is_return:\r\n    # Only for regular invoices (not Credit Notes)\r\n    customer = doc.customer\r\n\r\n    if customer:\r\n        # Check if ERPNext's auto-allocation already ran\r\n        erpnext_auto_allocated = doc.get('allocate_advances_automatically', 0) == 1\r\n\r\n        # Check if user manually added advances\r\n        existing_advances = len(doc.advances) if doc.advances else 0\r\n\r\n        if existing_advances == 0 and not erpnext_auto_allocated:\r\n            # No existing allocations - safe to auto-fill\r\n            # Get ALL submitted Payment Entries for this customer (FIFO)\r\n            # Note: We query basic fields first, then get unallocated_amount from document\r\n            payment_entries = frappe.db.sql(\"\"\"\r\n                SELECT\r\n                    pe.name,\r\n                    pe.posting_date,\r\n                    pe.paid_amount\r\n                FROM `tabPayment Entry` pe\r\n                WHERE pe.party_type = 'Customer'\r\n                AND pe.party = %s\r\n                AND pe.payment_type = 'Receive'\r\n                AND pe.docstatus = 1\r\n                ORDER BY pe.posting_date ASC, pe.creation ASC\r\n            \"\"\", (customer,), as_dict=1)\r\n\r\n            if payment_entries:\r\n                # Clear existing advances (if any)\r\n                doc.advances = []\r\n\r\n                total_allocated = 0\r\n                allocated_count = 0\r\n\r\n                # Allocate to invoice in FIFO order\r\n                for entry in payment_entries:\r\n                    # Get Payment Entry document to access calculated field\r\n                    pe_doc = frappe.get_doc(\"Payment Entry\", entry.name)\r\n\r\n                    # Get unallocated_amount from document (calculated field)\r\n                    available_amount = pe_doc.unallocated_amount or 0\r\n\r\n                    # Skip if this PE has no unallocated amount\r\n                    if available_amount <= 0:\r\n                        continue\r\n\r\n                    # Calculate how much to allocate from this PE\r\n                    remaining_to_allocate = doc.grand_total - total_allocated\r\n                    allocate_amount = min(available_amount, remaining_to_allocate)\r\n\r\n                    if allocate_amount > 0:\r\n                        # Add to advances table\r\n                        doc.append(\"advances\", {\r\n                            \"reference_type\": \"Payment Entry\",\r\n                            \"reference_name\": entry.name,\r\n                            \"reference_row\": \"\",\r\n                            \"remarks\": \"Auto-allocated payment (PE: %s)\" % entry.name,\r\n                            \"advance_amount\": available_amount,\r\n                            \"allocated_amount\": allocate_amount\r\n                        })\r\n\r\n                        total_allocated = total_allocated + allocate_amount\r\n                        allocated_count = allocated_count + 1\r\n\r\n                    # Stop if we've allocated enough to cover the invoice\r\n                    if total_allocated >= doc.grand_total:\r\n                        break\r\n\r\n                if total_allocated > 0:\r\n                    remaining_outstanding = doc.grand_total - total_allocated\r\n\r\n                    if remaining_outstanding > 0:\r\n                        frappe.msgprint(\r\n                            \"Payment auto-allocated: <b>%s</b> from %s payment(s).<br>\"\r\n                            \"Remaining outstanding: <b>%s</b>\" % (\r\n                                frappe.format_value(total_allocated, {\"fieldtype\": \"Currency\"}),\r\n                                allocated_count,\r\n                                frappe.format_value(remaining_outstanding, {\"fieldtype\": \"Currency\"})\r\n                            ),\r\n                            indicator=\"blue\",\r\n                            title=\"Payments Auto-Allocated\"\r\n                        )\r\n                    else:\r\n                        frappe.msgprint(\r\n                            \"Invoice fully paid from auto-allocated payments.<br>\"\r\n                            \"Amount: <b>%s</b> from %s payment(s).\" % (\r\n                                frappe.format_value(total_allocated, {\"fieldtype\": \"Currency\"}),\r\n                                allocated_count\r\n                            ),\r\n                            indicator=\"green\",\r\n                            title=\"Fully Paid\"\r\n                        )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.749688",
  "module": "Electro Zone",
  "name": "Sales Order - Deduct Balance on Submit",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# Sales Order - Deduct Balance on Submit\r\n# Event: After Submit\r\n# Purpose: Deduct SO total from customer balance (allow negative balance for credit sales)\r\n\r\n# Get customer and SO total\r\ncustomer = doc.customer\r\nso_total = doc.grand_total\r\n\r\n# Get current balance (can go negative - credit sales allowed)\r\ncurrent_balance = frappe.db.get_value(\"Customer\", customer, \"custom_current_balance\") or 0.0\r\n\r\n# Calculate new balance (explicit assignment - no augmented operators)\r\nnew_balance = current_balance - so_total\r\n\r\n# Update balance\r\nfrappe.db.set_value(\"Customer\", customer, \"custom_current_balance\", new_balance, update_modified=False)\r\n\r\n# Create Customer Balance Ledger entry\r\nledger = frappe.new_doc(\"Customer Balance Ledger\")\r\nledger.transaction_date = doc.transaction_date\r\nledger.posting_time = frappe.utils.nowtime()\r\nledger.customer = customer\r\nledger.customer_name = doc.customer_name\r\nledger.reference_doctype = \"Sales Order\"\r\nledger.reference_document = doc.name\r\nledger.reference_date = doc.transaction_date\r\nledger.debit_amount = so_total  # Deduct from customer credit\r\nledger.credit_amount = 0.0\r\nledger.balance_before = current_balance\r\nledger.running_balance = new_balance\r\nledger.remarks = \"Sales Order %s - Balance deducted (Order committed)\" % doc.name\r\nledger.company = doc.company\r\nledger.created_by = frappe.session.user\r\nledger.insert(ignore_permissions=True)\r\n\r\n# Show balance change notification\r\nfrappe.msgprint(\r\n    \"Customer balance updated:<br>\"\r\n    \"• Previous balance: <b>%s</b><br>\"\r\n    \"• Order amount: <b>%s</b><br>\"\r\n    \"• New balance: <b>%s</b><br><br>\"\r\n    \"%s\" % (\r\n        frappe.format_value(current_balance, {\"fieldtype\": \"Currency\"}),\r\n        frappe.format_value(so_total, {\"fieldtype\": \"Currency\"}),\r\n        frappe.format_value(new_balance, {\"fieldtype\": \"Currency\"}),\r\n        \"<b>Note:</b> Customer has credit (prepaid)\" if new_balance > 0 else\r\n        \"<b>Note:</b> Fully settled\" if new_balance == 0 else\r\n        \"<b>Note:</b> Customer owes money (credit sale)\"\r\n    ),\r\n    indicator=\"green\" if new_balance >= 0 else \"orange\",\r\n    title=\"Balance Updated\"\r\n)",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.699381",
  "module": "Electro Zone",
  "name": "Delivery Note - Create Reference Ledger Entry",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Delivery Note",
  "script": "# Delivery Note - Create Reference Ledger Entry\r\n# Event: After Submit\r\n# Purpose: Track DN in ledger for audit trail (no balance change)\r\n\r\n# Only for regular deliveries (not returns)\r\nif not doc.is_return:\r\n    customer = doc.customer\r\n\r\n    # Get current balance (unchanged)\r\n    current_balance = frappe.db.get_value(\"Customer\", customer, \"custom_current_balance\") or 0.0\r\n\r\n    # Find linked Sales Order\r\n    sales_order = None\r\n    for item in doc.items:\r\n        if item.get(\"against_sales_order\"):\r\n            sales_order = item.against_sales_order\r\n            break\r\n\r\n    # Create REFERENCE-ONLY ledger entry\r\n    ledger = frappe.new_doc(\"Customer Balance Ledger\")\r\n    ledger.transaction_date = doc.posting_date\r\n    ledger.posting_time = doc.posting_time or frappe.utils.nowtime()\r\n    ledger.customer = customer\r\n    ledger.customer_name = doc.customer_name\r\n    ledger.reference_doctype = \"Delivery Note\"\r\n    ledger.reference_document = doc.name\r\n    ledger.reference_date = doc.posting_date\r\n    ledger.debit_amount = 0.0  # NO change - reference only\r\n    ledger.credit_amount = 0.0  # NO change - reference only\r\n    ledger.balance_before = current_balance\r\n    ledger.running_balance = current_balance  # UNCHANGED\r\n    ledger.remarks = \"Delivery Note %s - Goods delivered (SO: %s)\" % (\r\n        doc.name,\r\n        sales_order or \"N/A\"\r\n    )\r\n    ledger.company = doc.company\r\n    ledger.created_by = frappe.session.user\r\n    ledger.insert(ignore_permissions=True)",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "get_po_ordered_qty",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.677348",
  "module": "Electro Zone",
  "name": "Purchase Order - Get PO Ordered Quantity for Barcode",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# API: Get ordered quantity from Purchase Order\r\n# Runs with elevated permissions (bypasses Stock User restrictions)\r\n\r\npo_reference = frappe.form_dict.get(\"po_reference\")\r\nitem_code = frappe.form_dict.get(\"item_code\")\r\n\r\nif not po_reference or not item_code:\r\n    frappe.response[\"message\"] = {\r\n        \"success\": False,\r\n        \"error\": \"Missing po_reference or item_code\"\r\n    }\r\nelse:\r\n    # Get ordered quantity from Purchase Order Item\r\n    ordered_qty = frappe.db.get_value(\"Purchase Order Item\", {\r\n        \"parent\": po_reference,\r\n        \"item_code\": item_code\r\n    }, \"qty\")\r\n\r\n    if ordered_qty:\r\n        frappe.response[\"message\"] = {\r\n            \"success\": True,\r\n            \"ordered_qty\": ordered_qty\r\n        }\r\n    else:\r\n        frappe.response[\"message\"] = {\r\n            \"success\": False,\r\n            \"error\": \"Item not found in Purchase Order\"\r\n        }\r\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "item_list_get_items_with_stock",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.676316",
  "module": "Electro Zone",
  "name": "Item - Get Items with Stock API",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# Server Script: Item List - Get Items with Stock API\r\n# Script Type: API\r\n# API Method: custom_app.item_list.get_items_with_stock\r\n# Purpose: Fetch item details and warehouse stock quantities as JSON\r\n\r\n# Define warehouse list\r\nwarehouses = [\r\n    \"Store Display - EZ\",\r\n    \"Store Warehouse - EZ\",\r\n    \"Damage - EZ\",\r\n    \"Damage For Sale - EZ\",\r\n    \"Zahran Main - EZ\",\r\n    \"Hold (Reserved / Pending Shipment) - EZ\"\r\n]\r\n\r\n# Get all items with required fields\r\nitems = frappe.db.get_all(\r\n    \"Item\",\r\n    filters={\"is_stock_item\": 1},\r\n    fields=[\"item_code\", \"custom_item_model\", \"description\"],\r\n    order_by=\"item_code\"\r\n)\r\n\r\n# Prepare result array\r\nresult = []\r\n\r\nfor item in items:\r\n    # Create row with item details\r\n    row = {\r\n        \"item_code\": item.get(\"item_code\"),\r\n        \"custom_item_model\": item.get(\"custom_item_model\") or \"\",\r\n        \"description\": item.get(\"description\") or \"\"\r\n    }\r\n\r\n    # Get stock quantities for each warehouse\r\n    for warehouse in warehouses:\r\n        # Query Bin doctype for actual_qty\r\n        qty = frappe.db.get_value(\r\n            \"Bin\",\r\n            {\"item_code\": item.get(\"item_code\"), \"warehouse\": warehouse},\r\n            \"actual_qty\"\r\n        ) or 0\r\n\r\n        # Add warehouse column to row\r\n        # Use warehouse name as key\r\n        row[warehouse] = qty\r\n\r\n    result.append(row)\r\n\r\n# Return JSON response\r\nfrappe.response[\"message\"] = {\r\n    \"success\": True,\r\n    \"items\": result,\r\n    \"warehouses\": warehouses,\r\n    \"total_count\": len(result)\r\n}\r\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "receive_dn_return",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.672314",
  "module": "Electro Zone",
  "name": "Delivery Note - Issue Return API",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# DN Return - Receive Return API\r\n# Purpose: Transition DN Return from Return Issued to Return Received\r\n# Creates Credit Note, updates balance, returns stock\r\n# API Endpoint: /api/method/receive_dn_return\r\n# Parameters: dn_return_name\r\n\r\n# Get DN Return name from request\r\ndn_return_name = frappe.form_dict.get(\"dn_return_name\")\r\n\r\nif not dn_return_name:\r\n    frappe.response[\"message\"] = {\r\n        \"success\": False,\r\n        \"message\": \"DN Return name is required\"\r\n    }\r\nelse:\r\n    # Get DN Return document\r\n    dn_return = frappe.get_doc(\"Delivery Note\", dn_return_name)\r\n\r\n    # Validate it's a return and in correct status\r\n    if dn_return.is_return != 1:\r\n        frappe.response[\"message\"] = {\r\n            \"success\": False,\r\n            \"message\": \"This is not a DN Return\"\r\n        }\r\n    else:\r\n        if dn_return.custom_return_status != \"Return Issued\":\r\n            frappe.response[\"message\"] = {\r\n                \"success\": False,\r\n                \"message\": \"DN Return must be in 'Return Issued' status\"\r\n            }\r\n        else:\r\n            # Find the original Sales Invoice\r\n            sales_invoices = frappe.db.get_all(\r\n                \"Sales Invoice Item\",\r\n                filters={\"delivery_note\": dn_return.return_against},\r\n                fields=[\"parent\"],\r\n                distinct=True\r\n            )\r\n\r\n            if not sales_invoices:\r\n                frappe.response[\"message\"] = {\r\n                    \"success\": False,\r\n                    \"message\": \"No Sales Invoice found for original DN: %s\" % dn_return.return_against\r\n                }\r\n            else:\r\n                original_si_name = sales_invoices[0].parent\r\n\r\n                # Check if Credit Note already exists\r\n                existing_credit_note = frappe.db.get_all(\r\n                    \"Sales Invoice\",\r\n                    filters={\r\n                        \"is_return\": 1,\r\n                        \"return_against\": original_si_name,\r\n                        \"docstatus\": [\"in\", [0, 1]]\r\n                    },\r\n                    limit=1\r\n                )\r\n\r\n                if existing_credit_note:\r\n                    frappe.response[\"message\"] = {\r\n                        \"success\": False,\r\n                        \"message\": \"Credit Note already exists: %s\" % existing_credit_note[0].name\r\n                    }\r\n                else:\r\n                    # IMPORTANT: Update DN Return status to \"Return Received\" BEFORE creating Credit Note\r\n                    # This allows the validation script to pass when Credit Note is inserted\r\n                    try:\r\n                        # ⭐ STEP 1: Get original source warehouse from Sales Order FIRST\r\n                        # This is CRITICAL - returns must go to original source, NOT Hold warehouse\r\n                        so_name = None\r\n                        original_source_warehouse = None\r\n\r\n                        # Find SO from original DN (not DN Return)\r\n                        so_names = frappe.db.sql(\"\"\"\r\n                            SELECT DISTINCT dni.against_sales_order\r\n                            FROM `tabDelivery Note Item` dni\r\n                            WHERE dni.parent = %s\r\n                                AND dni.against_sales_order IS NOT NULL\r\n                                AND dni.against_sales_order != ''\r\n                        \"\"\", (dn_return.return_against,), as_dict=1)\r\n\r\n                        if so_names and len(so_names) > 0:\r\n                            so_name = so_names[0].against_sales_order\r\n\r\n                            # Get original source warehouse from SO\r\n                            original_source_warehouse = frappe.db.get_value(\r\n                                \"Sales Order\",\r\n                                so_name,\r\n                                \"custom_source_warehouse\"\r\n                            )\r\n\r\n                        if not original_source_warehouse:\r\n                            frappe.throw(\r\n                                \"Cannot find original source warehouse from Sales Order %s. \"\r\n                                \"Returns must go to the original source warehouse, not Hold warehouse.\" % (so_name or \"Unknown\")\r\n                            )\r\n\r\n                        # ⭐ STEP 2: Update DN Return items' warehouse to original source warehouse\r\n                        # This ensures Credit Note will return stock to correct warehouse\r\n                        for item in dn_return.items:\r\n                            frappe.db.set_value(\r\n                                \"Delivery Note Item\",\r\n                                item.name,\r\n                                \"warehouse\",\r\n                                original_source_warehouse\r\n                            )\r\n\r\n                        # Reload DN Return to get updated warehouse values\r\n                        dn_return.reload()\r\n\r\n                        # ⭐ STEP 3: Update DN Return status to \"Return Received\"\r\n                        # CRITICAL: Also update workflow_state to keep workflow in sync\r\n                        frappe.db.set_value(\r\n                            \"Delivery Note\",\r\n                            dn_return_name,\r\n                            {\r\n                                \"custom_return_status\": \"Return Received\",\r\n                                \"status\": \"Return Received\",\r\n                                \"workflow_state\": \"Return Received\"\r\n                            }\r\n                        )\r\n\r\n                        # ⭐ STEP 4: Now create Credit Note with corrected warehouse\r\n                        # (validation will pass because status is \"Return Received\")\r\n                        credit_note = frappe.new_doc(\"Sales Invoice\")\r\n\r\n                        # Basic details\r\n                        credit_note.customer = dn_return.customer\r\n                        credit_note.company = dn_return.company\r\n                        # Use current date/time to ensure posting timestamp is AFTER original SI\r\n                        credit_note.posting_date = frappe.utils.nowdate()\r\n                        credit_note.posting_time = frappe.utils.nowtime()\r\n                        credit_note.set_posting_time = 1\r\n\r\n                        # Mark as return\r\n                        credit_note.is_return = 1\r\n                        credit_note.return_against = original_si_name\r\n\r\n                        # ⭐ FLAG: Mark as API-created to allow validation to pass\r\n                        # This prevents manual Credit Note creation (forces DN Return workflow)\r\n                        credit_note.custom_from_receive_return_api = 1\r\n\r\n                        # Copy customer details\r\n                        credit_note.customer_name = dn_return.customer_name\r\n                        if dn_return.get(\"contact_mobile\"):\r\n                            credit_note.contact_mobile = dn_return.contact_mobile\r\n\r\n                        # Copy items from DN Return (now with corrected warehouse)\r\n                        for item in dn_return.items:\r\n                            credit_note.append(\"items\", {\r\n                                \"item_code\": item.item_code,\r\n                                \"item_name\": item.item_name,\r\n                                \"description\": item.description,\r\n                                \"qty\": item.qty,  # Already negative\r\n                                \"uom\": item.uom,\r\n                                \"stock_uom\": item.stock_uom,\r\n                                \"conversion_factor\": item.conversion_factor,\r\n                                \"rate\": item.rate,\r\n                                \"amount\": item.amount,\r\n                                \"warehouse\": item.warehouse,  # Now points to original source warehouse\r\n                                \"delivery_note\": dn_return.name,\r\n                                \"dn_detail\": item.name\r\n                            })\r\n\r\n                        # Insert and submit Credit Note\r\n                        credit_note.insert()\r\n                        credit_note.submit()\r\n\r\n                        # Customer Balance is updated automatically by Sales Invoice script\r\n                        # No need to update it here - the Sales Invoice After Submit script\r\n                        # handles updating Customer.custom_current_balance and creating ledger entry\r\n\r\n                        # ⭐ STEP 5: Stock is automatically returned to original source warehouse\r\n                        # When Credit Note is submitted, ERPNext creates Stock Entry:\r\n                        # - From: Hold (Reserved / Pending Shipment) - where items currently are\r\n                        # - To: {original_source_warehouse} - where they came from originally\r\n                        # This happens automatically because we updated DN Return items' warehouse field\r\n\r\n                        # ⭐ STEP 6: Update Sales Order: mark as returned and close\r\n                        # (so_name already retrieved in STEP 1)\r\n                        if so_name:\r\n                            frappe.db.set_value(\r\n                                \"Sales Order\",\r\n                                so_name,\r\n                                {\r\n                                    \"custom_is_returned\": 1,\r\n                                    \"custom_return_date\": frappe.utils.nowdate(),\r\n                                    \"custom_return_reference\": dn_return_name,\r\n                                    \"status\": \"Closed\"\r\n                                }\r\n                            )\r\n\r\n                        # Get updated balance for response\r\n                        updated_balance = frappe.db.get_value(\"Customer\", dn_return.customer, \"custom_current_balance\") or 0\r\n\r\n                        frappe.response[\"message\"] = {\r\n                            \"success\": True,\r\n                            \"message\": \"Return received successfully. Credit Note: %s, Customer Balance: %s\" % (credit_note.name, updated_balance)\r\n                        }\r\n\r\n                    except Exception as e:\r\n                        # Rollback DN Return status if Credit Note creation fails\r\n                        frappe.db.set_value(\r\n                            \"Delivery Note\",\r\n                            dn_return_name,\r\n                            {\r\n                                \"custom_return_status\": \"Return Issued\",\r\n                                \"status\": \"Return Issued\"\r\n                            }\r\n                        )\r\n\r\n                        frappe.log_error(\"DN Return Error: %s\" % str(e), \"DN Return Processing Failed\")\r\n                        frappe.response[\"message\"] = {\r\n                            \"success\": False,\r\n                            \"message\": \"Failed to process return: %s\" % str(e)\r\n                        }",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "receive_dn_return",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.674207",
  "module": "Electro Zone",
  "name": "Delivery Note - Receive Return API",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# DN Return - Receive Return API\r\n# Purpose: Transition DN Return from Return Issued to Return Received\r\n# Creates Credit Note, updates balance, returns stock\r\n# API Endpoint: /api/method/receive_dn_return\r\n# Parameters: dn_return_name\r\n\r\n# Get DN Return name from request\r\ndn_return_name = frappe.form_dict.get(\"dn_return_name\")\r\n\r\nif not dn_return_name:\r\n    frappe.response[\"message\"] = {\r\n        \"success\": False,\r\n        \"message\": \"DN Return name is required\"\r\n    }\r\nelse:\r\n    # Get DN Return document\r\n    dn_return = frappe.get_doc(\"Delivery Note\", dn_return_name)\r\n\r\n    # Validate it's a return and in correct status\r\n    if dn_return.is_return != 1:\r\n        frappe.response[\"message\"] = {\r\n            \"success\": False,\r\n            \"message\": \"This is not a DN Return\"\r\n        }\r\n    else:\r\n        if dn_return.custom_return_status != \"Return Issued\":\r\n            frappe.response[\"message\"] = {\r\n                \"success\": False,\r\n                \"message\": \"DN Return must be in 'Return Issued' status\"\r\n            }\r\n        else:\r\n            # Find the original Sales Invoice\r\n            sales_invoices = frappe.db.get_all(\r\n                \"Sales Invoice Item\",\r\n                filters={\"delivery_note\": dn_return.return_against},\r\n                fields=[\"parent\"],\r\n                distinct=True\r\n            )\r\n\r\n            if not sales_invoices:\r\n                frappe.response[\"message\"] = {\r\n                    \"success\": False,\r\n                    \"message\": \"No Sales Invoice found for original DN: %s\" % dn_return.return_against\r\n                }\r\n            else:\r\n                original_si_name = sales_invoices[0].parent\r\n\r\n                # Check if Credit Note already exists\r\n                existing_credit_note = frappe.db.get_all(\r\n                    \"Sales Invoice\",\r\n                    filters={\r\n                        \"is_return\": 1,\r\n                        \"return_against\": original_si_name,\r\n                        \"docstatus\": [\"in\", [0, 1]]\r\n                    },\r\n                    limit=1\r\n                )\r\n\r\n                if existing_credit_note:\r\n                    frappe.response[\"message\"] = {\r\n                        \"success\": False,\r\n                        \"message\": \"Credit Note already exists: %s\" % existing_credit_note[0].name\r\n                    }\r\n                else:\r\n                    # IMPORTANT: Update DN Return status to \"Return Received\" BEFORE creating Credit Note\r\n                    # This allows the validation script to pass when Credit Note is inserted\r\n                    try:\r\n                        # ⭐ STEP 1: Get original source warehouse from Sales Order FIRST\r\n                        # This is CRITICAL - returns must go to original source, NOT Hold warehouse\r\n                        so_name = None\r\n                        original_source_warehouse = None\r\n\r\n                        # Find SO from original DN (not DN Return)\r\n                        so_names = frappe.db.sql(\"\"\"\r\n                            SELECT DISTINCT dni.against_sales_order\r\n                            FROM `tabDelivery Note Item` dni\r\n                            WHERE dni.parent = %s\r\n                                AND dni.against_sales_order IS NOT NULL\r\n                                AND dni.against_sales_order != ''\r\n                        \"\"\", (dn_return.return_against,), as_dict=1)\r\n\r\n                        if so_names and len(so_names) > 0:\r\n                            so_name = so_names[0].against_sales_order\r\n\r\n                            # Get original source warehouse from SO\r\n                            original_source_warehouse = frappe.db.get_value(\r\n                                \"Sales Order\",\r\n                                so_name,\r\n                                \"custom_source_warehouse\"\r\n                            )\r\n\r\n                        if not original_source_warehouse:\r\n                            frappe.throw(\r\n                                \"Cannot find original source warehouse from Sales Order %s. \"\r\n                                \"Returns must go to the original source warehouse, not Hold warehouse.\" % (so_name or \"Unknown\")\r\n                            )\r\n\r\n                        # ⭐ STEP 2: Update DN Return items' warehouse to original source warehouse\r\n                        # This ensures Credit Note will return stock to correct warehouse\r\n                        for item in dn_return.items:\r\n                            frappe.db.set_value(\r\n                                \"Delivery Note Item\",\r\n                                item.name,\r\n                                \"warehouse\",\r\n                                original_source_warehouse\r\n                            )\r\n\r\n                        # Reload DN Return to get updated warehouse values\r\n                        dn_return.reload()\r\n\r\n                        # ⭐ STEP 3: Update DN Return status to \"Return Received\"\r\n                        # CRITICAL: Also update workflow_state to keep workflow in sync\r\n                        frappe.db.set_value(\r\n                            \"Delivery Note\",\r\n                            dn_return_name,\r\n                            {\r\n                                \"custom_return_status\": \"Return Received\",\r\n                                \"status\": \"Return Received\",\r\n                                \"workflow_state\": \"Return Received\"\r\n                            }\r\n                        )\r\n\r\n                        # ⭐ STEP 4: Now create Credit Note with corrected warehouse\r\n                        # (validation will pass because status is \"Return Received\")\r\n                        credit_note = frappe.new_doc(\"Sales Invoice\")\r\n\r\n                        # Basic details\r\n                        credit_note.customer = dn_return.customer\r\n                        credit_note.company = dn_return.company\r\n                        # Use current date/time to ensure posting timestamp is AFTER original SI\r\n                        credit_note.posting_date = frappe.utils.nowdate()\r\n                        credit_note.posting_time = frappe.utils.nowtime()\r\n                        credit_note.set_posting_time = 1\r\n\r\n                        # Mark as return\r\n                        credit_note.is_return = 1\r\n                        credit_note.return_against = original_si_name\r\n\r\n                        # ⭐ FLAG: Mark as API-created to allow validation to pass\r\n                        # This prevents manual Credit Note creation (forces DN Return workflow)\r\n                        credit_note.custom_from_receive_return_api = 1\r\n\r\n                        # Copy customer details\r\n                        credit_note.customer_name = dn_return.customer_name\r\n                        if dn_return.get(\"contact_mobile\"):\r\n                            credit_note.contact_mobile = dn_return.contact_mobile\r\n\r\n                        # Copy items from DN Return (now with corrected warehouse)\r\n                        for item in dn_return.items:\r\n                            credit_note.append(\"items\", {\r\n                                \"item_code\": item.item_code,\r\n                                \"item_name\": item.item_name,\r\n                                \"description\": item.description,\r\n                                \"qty\": item.qty,  # Already negative\r\n                                \"uom\": item.uom,\r\n                                \"stock_uom\": item.stock_uom,\r\n                                \"conversion_factor\": item.conversion_factor,\r\n                                \"rate\": item.rate,\r\n                                \"amount\": item.amount,\r\n                                \"warehouse\": item.warehouse,  # Now points to original source warehouse\r\n                                \"delivery_note\": dn_return.name,\r\n                                \"dn_detail\": item.name\r\n                            })\r\n\r\n                        # Insert and submit Credit Note\r\n                        credit_note.insert()\r\n                        credit_note.submit()\r\n\r\n                        # Customer Balance is updated automatically by Sales Invoice script\r\n                        # No need to update it here - the Sales Invoice After Submit script\r\n                        # handles updating Customer.custom_current_balance and creating ledger entry\r\n\r\n                        # ⭐ STEP 5: Stock is automatically returned to original source warehouse\r\n                        # When Credit Note is submitted, ERPNext creates Stock Entry:\r\n                        # - From: Hold (Reserved / Pending Shipment) - where items currently are\r\n                        # - To: {original_source_warehouse} - where they came from originally\r\n                        # This happens automatically because we updated DN Return items' warehouse field\r\n\r\n                        # ⭐ STEP 6: Update Sales Order: mark as returned and close\r\n                        # (so_name already retrieved in STEP 1)\r\n                        if so_name:\r\n                            frappe.db.set_value(\r\n                                \"Sales Order\",\r\n                                so_name,\r\n                                {\r\n                                    \"custom_is_returned\": 1,\r\n                                    \"custom_return_date\": frappe.utils.nowdate(),\r\n                                    \"custom_return_reference\": dn_return_name,\r\n                                    \"status\": \"Closed\"\r\n                                }\r\n                            )\r\n\r\n                        # Get updated balance for response\r\n                        updated_balance = frappe.db.get_value(\"Customer\", dn_return.customer, \"custom_current_balance\") or 0\r\n\r\n                        frappe.response[\"message\"] = {\r\n                            \"success\": True,\r\n                            \"message\": \"Return received successfully. Credit Note: %s, Customer Balance: %s\" % (credit_note.name, updated_balance)\r\n                        }\r\n\r\n                    except Exception as e:\r\n                        # Rollback DN Return status if Credit Note creation fails\r\n                        frappe.db.set_value(\r\n                            \"Delivery Note\",\r\n                            dn_return_name,\r\n                            {\r\n                                \"custom_return_status\": \"Return Issued\",\r\n                                \"status\": \"Return Issued\"\r\n                            }\r\n                        )\r\n\r\n                        frappe.log_error(\"DN Return Error: %s\" % str(e), \"DN Return Processing Failed\")\r\n                        frappe.response[\"message\"] = {\r\n                            \"success\": False,\r\n                            \"message\": \"Failed to process return: %s\" % str(e)\r\n                        }",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Cancel",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.695414",
  "module": "Electro Zone",
  "name": "Delivery Note - Auto Close Sales Order on Cancel",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Delivery Note",
  "script": "# DN - Auto Close Sales Order on Cancel\r\n# Trigger: After Cancel\r\n# Purpose: Close linked Sales Order when DN is canceled\r\n\r\n# Get all Sales Order references from DN items\r\nsales_orders = set()\r\nfor item in doc.items:\r\n    if item.against_sales_order:\r\n        sales_orders.add(item.against_sales_order)\r\n\r\n# Close each linked Sales Order\r\nfor so_name in sales_orders:\r\n    # Check if SO exists and is not already closed or cancelled\r\n    so = frappe.get_doc(\"Sales Order\", so_name)\r\n\r\n    # Only close if SO is still open (not closed or cancelled)\r\n    if so.docstatus == 1 and so.status != \"Closed\":\r\n        # Close the Sales Order\r\n        so.update_status(\"Closed\")\r\n\r\n        # Add comment to SO\r\n        so.add_comment(\"Comment\",\r\n            \"Sales Order automatically closed because Delivery Note %s was canceled by %s\" % (\r\n                doc.name, frappe.session.user\r\n            )\r\n        )\r\n\r\n        frappe.msgprint(\r\n            \"Sales Order %s has been automatically closed.\" % so_name,\r\n            indicator=\"orange\",\r\n            title=\"SO Auto-Closed\"\r\n        )\r\n\r\n# Add comment to DN\r\nif sales_orders:\r\n    doc.add_comment(\"Comment\",\r\n        \"Linked Sales Order(s) automatically closed: %s\" % \", \".join(sales_orders)\r\n    )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.696740",
  "module": "Electro Zone",
  "name": "Delivery Note - Auto Invoice on Out for Delivery",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Delivery Note",
  "script": "# DN - Auto Invoice on Out for Delivery\r\n# Purpose: Auto-create SI when DN is submitted to \"Delivered\" state\r\n# Event: After Submit\r\n# UPDATED (2025-12-28): Changed to After Submit event, triggers on \"Out for Delivery\"\r\n# FIXED (2025-12-22): Added retry logic to handle Payment Entry concurrency conflicts\r\n\r\n# Only process when DN moves to \"Delivered\" state (non-return DNs)\r\nif doc.workflow_state == \"Delivered\" and doc.is_return != 1:\r\n    # Check if invoice already exists\r\n    existing = frappe.db.exists(\"Sales Invoice Item\", {\r\n        \"delivery_note\": doc.name,\r\n        \"docstatus\": [\"!=\", 2]\r\n    })\r\n\r\n    if existing:\r\n        frappe.msgprint(f\"Sales Invoice already exists for DN {doc.name}\", indicator=\"orange\")\r\n    else:\r\n        # Retry logic to handle concurrency conflicts\r\n        max_retries = 3\r\n        retry_count = 0\r\n        success = False\r\n        last_error = None\r\n\r\n        while retry_count < max_retries and not success:\r\n            try:\r\n                # Balance is now handled ONLY in Sales Invoice After Submit script (file 19)\r\n                # This prevents double-deduction bug\r\n\r\n                # Create Sales Invoice (always as Draft - SI script will handle submission)\r\n                si = frappe.new_doc(\"Sales Invoice\")\r\n                si.customer = doc.customer\r\n                si.posting_date = frappe.utils.nowdate()\r\n                si.company = doc.company\r\n\r\n                # Copy items\r\n                for dn_item in doc.items:\r\n                    si.append(\"items\", {\r\n                        \"item_code\": dn_item.item_code,\r\n                        \"item_name\": dn_item.item_name,\r\n                        \"description\": dn_item.description,\r\n                        \"qty\": dn_item.qty,\r\n                        \"rate\": dn_item.rate,\r\n                        \"amount\": dn_item.amount,\r\n                        \"warehouse\": dn_item.warehouse,\r\n                        \"uom\": dn_item.uom,\r\n                        \"stock_uom\": dn_item.stock_uom,\r\n                        \"conversion_factor\": dn_item.conversion_factor or 1,\r\n                        \"delivery_note\": doc.name,\r\n                        \"dn_detail\": dn_item.name,\r\n                        \"sales_order\": dn_item.against_sales_order\r\n                    })\r\n\r\n                # Copy taxes if any\r\n                for tax in doc.get(\"taxes\", []):\r\n                    si.append(\"taxes\", {\r\n                        \"charge_type\": tax.charge_type,\r\n                        \"account_head\": tax.account_head,\r\n                        \"description\": tax.description,\r\n                        \"rate\": tax.get(\"rate\", 0),\r\n                        \"tax_amount\": tax.tax_amount\r\n                    })\r\n\r\n                # Insert and submit invoice automatically\r\n                si.insert(ignore_permissions=True)\r\n                si.submit()\r\n\r\n                # IMPORTANT: Balance updates handled by SI After Submit script (file 19)\r\n                # SI After Submit script handles:\r\n                # 1. Balance updates (prevents double-deduction)\r\n                # 2. SO advance recognition\r\n                # 3. FIFO payment allocation\r\n\r\n                # Show success message\r\n                frappe.msgprint(\r\n                    f\"Sales Invoice {si.name} created and submitted automatically.<br>\"\r\n                    \"Payment processing completed via SI After Submit script.\",\r\n                    alert=True,\r\n                    indicator=\"green\",\r\n                    title=\"Invoice Submitted\"\r\n                )\r\n\r\n                # Add comment to DN\r\n                doc.add_comment(\"Comment\", f\"Sales Invoice {si.name} auto-created from Delivery Note {doc.name}\")\r\n\r\n                # Mark as successful\r\n                success = True\r\n\r\n            except Exception as e:\r\n                last_error = str(e)\r\n                retry_count = retry_count + 1\r\n\r\n                # Check if it's a concurrency error that we can retry\r\n                is_concurrency_error = (\r\n                    \"modified after you pulled\" in last_error or\r\n                    \"has been modified\" in last_error or\r\n                    \"TimestampMismatchError\" in last_error\r\n                )\r\n\r\n                if is_concurrency_error and retry_count < max_retries:\r\n                    # Log retry attempt\r\n                    frappe.log_error(\r\n                        f\"Retry {retry_count}/{max_retries} for DN {doc.name}: {last_error}\",\r\n                        \"DN Auto Invoice Retry\"\r\n                    )\r\n                    # Wait briefly before retry (using database query as delay mechanism)\r\n                    # This gives other transactions time to complete\r\n                    frappe.db.sql(\"SELECT SLEEP(0.5)\")\r\n                    continue\r\n                else:\r\n                    # Not a concurrency error or max retries reached\r\n                    break\r\n\r\n        # Handle final result\r\n        if not success:\r\n            frappe.log_error(\r\n                f\"Auto SI creation failed after {retry_count} retries: {last_error}\",\r\n                \"DN Auto Invoice Error\"\r\n            )\r\n            frappe.msgprint(\r\n                f\"❌ Failed to create Sales Invoice after {retry_count} retries.<br>\"\r\n                f\"Error: {last_error}<br><br>\"\r\n                \"Please try again or contact administrator.\",\r\n                alert=True,\r\n                indicator=\"red\",\r\n                title=\"Invoice Creation Failed\"\r\n            )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2026-01-01 00:43:22.694011",
  "module": "Electro Zone",
  "name": "Delivery Note -  Auto Return Stock on Delivery Failed",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Delivery Note",
  "script": "# DN - Auto Return Stock and Cancel on Delivery Failed\r\n# Trigger: After Submit\r\n# Purpose: When workflow_state = \"Delivery Failed\", return stock and auto-cancel DN\r\n\r\n# Only process regular DNs (not returns) - use if-else instead of return (RestrictedPython)\r\nif doc.is_return != 1:\r\n    # Check if this is a \"Delivery Failed\" submission\r\n    # Only process if workflow_state is \"Delivery Failed\" and we haven't processed it yet\r\n    if doc.workflow_state == \"Delivery Failed\":\r\n        # Check if already processed (prevent double-execution)\r\n        already_processed = frappe.db.exists(\"Comment\", {\r\n            \"reference_doctype\": \"Delivery Note\",\r\n            \"reference_name\": doc.name,\r\n            \"content\": [\"like\", \"%automatically cancelled due to Delivery Failed%\"]\r\n        })\r\n\r\n        # Only proceed if not already processed\r\n        if already_processed:\r\n            # Already processed, skip\r\n            pass\r\n        else:\r\n            # Process the delivery failed logic\r\n\r\n            # Get linked Sales Order to retrieve original source warehouse\r\n            so_name = None\r\n            for item in doc.items:\r\n                if item.get(\"against_sales_order\"):\r\n                    so_name = item.against_sales_order\r\n                    break\r\n\r\n            if not so_name:\r\n                frappe.throw(\"Cannot find linked Sales Order. Cannot determine source warehouse.\")\r\n\r\n            # Get original source warehouse from SO\r\n            source_warehouse = frappe.db.get_value(\"Sales Order\", so_name, \"custom_source_warehouse\")\r\n\r\n            if not source_warehouse:\r\n                frappe.throw(\"Source warehouse not found on Sales Order %s. Cannot return stock.\" % so_name)\r\n\r\n            # Find Hold warehouse (use warehouse_name field + company filter)\r\n            hold_warehouse = frappe.db.get_value(\r\n                \"Warehouse\",\r\n                {\r\n                    \"warehouse_name\": [\"like\", \"%Hold%\"],\r\n                    \"company\": doc.company,\r\n                    \"is_group\": 0\r\n                },\r\n                \"name\"\r\n            )\r\n\r\n            if not hold_warehouse:\r\n                frappe.throw(\"Hold warehouse not found for company %s. Cannot return stock.\" % doc.company)\r\n\r\n            try:\r\n                # Step 1: Cancel the Delivery Note FIRST (unreserves stock in Hold warehouse)\r\n                # This is CRITICAL - DN submission reserves stock, we must cancel to unreserve it\r\n                # Use frappe.get_doc to get a fresh copy to avoid conflicts\r\n                dn = frappe.get_doc(\"Delivery Note\", doc.name)\r\n                dn.cancel()\r\n\r\n                # Step 2: NOW create Stock Entry to return unreserved stock\r\n                stock_entry = frappe.new_doc(\"Stock Entry\")\r\n                stock_entry.stock_entry_type = \"Material Transfer\"\r\n                stock_entry.company = doc.company\r\n                stock_entry.posting_date = frappe.utils.nowdate()\r\n                stock_entry.posting_time = frappe.utils.nowtime()\r\n\r\n                # Add items from DN\r\n                for item in doc.items:\r\n                    # Add item to Stock Entry (Hold → original source warehouse from SO)\r\n                    stock_entry.append(\"items\", {\r\n                        \"item_code\": item.item_code,\r\n                        \"qty\": item.qty,\r\n                        \"s_warehouse\": hold_warehouse,  # From Hold\r\n                        \"t_warehouse\": source_warehouse,  # Back to original source warehouse from SO\r\n                        \"uom\": item.uom,\r\n                        \"stock_uom\": item.stock_uom,\r\n                        \"conversion_factor\": item.conversion_factor or 1,\r\n                        \"transfer_qty\": item.qty * (item.conversion_factor or 1)\r\n                    })\r\n\r\n                # Create and submit Stock Entry\r\n                stock_entry.insert(ignore_permissions=True)\r\n                stock_entry.submit()\r\n\r\n                # Add comment to DN after stock return\r\n                comment_doc = frappe.new_doc(\"Comment\")\r\n                comment_doc.comment_type = \"Comment\"\r\n                comment_doc.reference_doctype = \"Delivery Note\"\r\n                comment_doc.reference_name = doc.name\r\n                comment_doc.content = \"DN cancelled due to Delivery Failed. Stock returned from Hold to %s via %s\" % (source_warehouse, stock_entry.name)\r\n                comment_doc.insert(ignore_permissions=True)\r\n\r\n                # Step 3: NOW close Sales Order with delivery failed tracking fields\r\n                # (so_name already retrieved earlier)\r\n                if so_name:\r\n                    # Set permanent tracking fields (similar to return tracking)\r\n                    frappe.db.set_value(\r\n                        \"Sales Order\",\r\n                        so_name,\r\n                        {\r\n                            \"custom_delivery_status\": \"Delivery Failed\",\r\n                            \"custom_is_delivery_failed\": 1,  # Permanent flag\r\n                            \"custom_delivery_failed_date\": frappe.utils.today(),\r\n                            \"custom_delivery_failed_reference\": doc.name,\r\n                            \"status\": \"Closed\"  # Close the SO\r\n                        },\r\n                        update_modified=False\r\n                    )\r\n\r\n                    # Add audit comment to SO\r\n                    so_doc = frappe.get_doc(\"Sales Order\", so_name)\r\n                    so_doc.add_comment(\r\n                        \"Comment\",\r\n                        \"Closed due to delivery failure: DN %s (workflow_state = Delivery Failed)\" % doc.name\r\n                    )\r\n\r\n                # Show single minimal message\r\n                frappe.msgprint(\r\n                    \"DN cancelled • Stock returned • SO closed\",\r\n                    indicator=\"orange\"\r\n                )\r\n\r\n            except Exception as e:\r\n                frappe.log_error(\"Failed to return stock or cancel DN %s: %s\" % (doc.name, str(e)))\r\n                frappe.throw(\"Failed to process Delivery Failed: %s\" % str(e))",
  "script_type": "DocType Event"
 }
]